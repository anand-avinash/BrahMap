{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BrahMap","text":"<p> This project is currently under active development!!! </p> <p><code>BrahMap</code> is a scalable and modular map-making framework for the CMB experiments. It features user-friendly Python interface for the linear operators used in map-making. The Python interface simply handles the workflow while delegating the heavy computations to the functions implemented in C++ extension. In addition to the interface for linear operators, <code>BrahMap</code> offers a wrapper for Generalized Least Squares (GLS) map-making using the Preconditioned Conjugate Gradient (PCG) solver. <code>BrahMap</code> is also integrated with <code>litebird_sim</code> through dedicated wrappers.</p> <p>For a quick introduction to map-making with BrahMap, refer to the quick start guide. For a complete reference of the <code>BrahMap</code> API, refer to the API reference. Complete example notebooks and scripts can be found here.</p> <p>You can find detailed information on the implementation and features of <code>BrahMap</code> at arXiv:2501.16122.</p>"},{"location":"#citation","title":"Citation","text":"<p>This work can be cited with:</p> <pre><code>@misc{anand2025brahmap,\n      title={\\texttt{BrahMap}: A scalable and modular map-making framework for the CMB experiments}, \n      author={Avinash Anand and Giuseppe Puglisi},\n      year={2025},\n      eprint={2501.16122},\n      archivePrefix={arXiv},\n      primaryClass={astro-ph.CO},\n      url={https://arxiv.org/abs/2501.16122}, \n}\n</code></pre>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>This work is supported by Italian Research Center on High Performance Computing, Big Data and Quantum Computing (ICSC), project funded by European Union - NextGenerationEU - and National Recovery and Resilience Plan (NRRP) - Mission 4 Component 2 within the activities of Spoke 3 (Astrophysics and Cosmos Observations).</p>"},{"location":"api_reference/","title":"API reference","text":""},{"location":"api_reference/#litebird_sim-api","title":"<code>litebird_sim</code> API","text":"<ul> <li><code>litebird_sim</code> Interface</li> </ul>"},{"location":"api_reference/#core-api","title":"Core API","text":"<ul> <li>Core Map-making Interface</li> <li>Math Functions</li> <li>Utilities</li> </ul>"},{"location":"api_reference/#base-api","title":"Base API","text":"<ul> <li>Base Operators</li> <li>Miscellaneous</li> </ul>"},{"location":"api_reference/#c-api","title":"C++ API","text":"<p>Under development </p>"},{"location":"api_reference/base_operators/","title":"Base Operators","text":""},{"location":"api_reference/base_operators/#linop-sub-module","title":"<code>linop</code> sub-module","text":"<ul> <li><code>BaseLinearOperator</code></li> <li><code>LinearOperator</code></li> <li><code>IdentityOperator</code></li> <li><code>DiagonalOperator</code></li> <li><code>MatrixLinearOperator</code></li> <li><code>ZeroOperator</code></li> <li><code>InverseLO</code></li> <li><code>ReducedLinearOperator</code></li> <li><code>SymmetricallyReducedLinearOperator</code></li> <li><code>aslinearoperator</code></li> </ul>"},{"location":"api_reference/base_operators/#blkop-sub-module","title":"<code>blkop</code> sub-module","text":"<ul> <li><code>BlockLinearOperator</code></li> <li><code>BlockDiagonalLinearOperator</code></li> <li><code>BlockHorizontalLinearOperator</code></li> <li><code>BlockVerticalLinearOperator</code></li> </ul>"},{"location":"api_reference/base_operators/#base-noise-covariance-and-inverse-operators","title":"Base noise covariance (and inverse) operators","text":"<ul> <li><code>NoiseCovLinearOperator</code></li> <li><code>InvNoiseCovLinearOperator</code></li> <li><code>BaseBlockDiagNoiseCovLinearOperator</code></li> <li><code>BaseBlockDiagInvNoiseCovLinearOperator</code></li> </ul>"},{"location":"api_reference/base_operators/BaseBlockDiagInvNoiseCovLinearOperator/","title":"<code>brahmap.base.BaseBlockDiagInvNoiseCovLinearOperator</code>","text":"<p>               Bases: <code>BaseBlockDiagNoiseCovLinearOperator</code></p> <p>Base class for block-diagonal inverse noise covariance operator</p> <p>Parameters:</p> Name Type Description Default <code>block_list</code> <code>List[InvNoiseCovLinearOperator]</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/noise_ops.py</code> <pre><code>class BaseBlockDiagInvNoiseCovLinearOperator(BaseBlockDiagNoiseCovLinearOperator):\n    \"\"\"Base class for block-diagonal inverse noise covariance operator\n\n    Parameters\n    ----------\n    block_list : List[InvNoiseCovLinearOperator]\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        block_list: List[InvNoiseCovLinearOperator],\n        **kwargs: Any,\n    ):\n        super(BaseBlockDiagInvNoiseCovLinearOperator, self).__init__(\n            block_list, **kwargs\n        )\n\n    def get_inverse(self) -&gt; \"BaseBlockDiagNoiseCovLinearOperator\":\n        inverse_list = [block.get_inverse() for block in self.block_list]\n        return BaseBlockDiagNoiseCovLinearOperator(block_list=inverse_list)\n</code></pre>"},{"location":"api_reference/base_operators/BaseBlockDiagNoiseCovLinearOperator/","title":"<code>brahmap.base.BaseBlockDiagNoiseCovLinearOperator</code>","text":"<p>               Bases: <code>BlockDiagonalLinearOperator</code></p> <p>Base class for block-diagonal noise covariance operator</p> <p>Parameters:</p> Name Type Description Default <code>block_list</code> <code>List[NoiseCovLinearOperator]</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/noise_ops.py</code> <pre><code>class BaseBlockDiagNoiseCovLinearOperator(BlockDiagonalLinearOperator):\n    \"\"\"Base class for block-diagonal noise covariance operator\n\n    Parameters\n    ----------\n    block_list : List[NoiseCovLinearOperator]\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        block_list: List[NoiseCovLinearOperator],\n        **kwargs: Any,\n    ):\n        super(BaseBlockDiagNoiseCovLinearOperator, self).__init__(block_list, **kwargs)\n\n        MPI_RAISE_EXCEPTION(\n            condition=(not self.symmetric),\n            exception=ValueError,\n            message=\"The noise (inv-)covariance operators must be symmetric\",\n        )\n\n    @property\n    def size(self) -&gt; int:\n        return sum(self.col_size)\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        diag = np.concatenate(\n            [block.diag for block in self.block_list],\n            axis=None,\n        )\n        return diag\n\n    def get_inverse(self) -&gt; \"BaseBlockDiagInvNoiseCovLinearOperator\":\n        inverse_list = [block.get_inverse() for block in self.block_list]\n        return BaseBlockDiagInvNoiseCovLinearOperator(block_list=inverse_list)\n</code></pre>"},{"location":"api_reference/base_operators/BaseLinearOperator/","title":"<code>brahmap.base.BaseLinearOperator</code>","text":"<p>               Bases: <code>object</code></p> <p>Base class for defining the common interface shared by all linear operators.</p> <p>A linear operator is a linear mapping \\(x \\mapsto A(x)\\) such that the size of the input vector \\(x\\) is <code>nargin</code> and the size of the output vector is <code>nargout</code>. The linear operator \\(A\\) can be visualized as a matrix of shape <code>(nargout, nargin)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>nargin</code> <code>int</code> <p>Size of the input vector \\(x\\)</p> required <code>nargout</code> <code>int</code> <p>Size of the output vector \\(A(x)\\)</p> required <code>symmetric</code> <code>bool</code> <p>A parameter to specify whether the linear operator is symmetric, by default <code>False</code></p> <code>False</code> <code>dtype</code> <code>DTypeLike</code> <p>Data type of the linear operator, by default <code>np.float64</code></p> <code>float64</code> <code>**kwargs</code> <code>Any</code> <p>Extra keywords arguments</p> <code>{}</code> Source code in <code>brahmap/base/linop.py</code> <pre><code>class BaseLinearOperator(object):\n    \"\"\"Base class for defining the common interface shared by all linear\n    operators.\n\n    A linear operator is a linear mapping $x \\\\mapsto A(x)$ such that the size\n    of the input vector $x$ is `nargin` and the size of the output vector is\n    `nargout`. The linear operator $A$ can be visualized as a matrix of shape\n    `(nargout, nargin)`.\n\n    Parameters\n    ----------\n    nargin : int\n        Size of the input vector $x$\n    nargout : int\n        Size of the output vector $A(x)$\n    symmetric : bool, optional\n        A parameter to specify whether the linear operator is symmetric, by\n        default `False`\n    dtype : npt.DTypeLike, optional\n        Data type of the linear operator, by default `np.float64`\n    **kwargs : Any\n        Extra keywords arguments\n    \"\"\"\n\n    # A logger may be attached to the linear operator via the `logger` keyword\n    # argument.\n\n    def __init__(\n        self,\n        nargin: int,\n        nargout: int,\n        symmetric: bool = False,\n        dtype: npt.DTypeLike = np.float64,\n        **kwargs,\n    ):\n        self.__nargin = nargin\n        self.__nargout = nargout\n        self.__symmetric = symmetric\n        self.__shape = (nargout, nargin)\n        self.dtype = dtype\n        self._nMatvec = 0\n\n        # Log activity.\n        self.logger = kwargs.get(\"logger\", null_log)\n        self.logger.info(\"New linear operator with shape \" + str(self.shape))\n        return\n\n    @property\n    def nargin(self) -&gt; int:\n        \"\"\"The size of the input vector.\"\"\"\n        return self.__nargin\n\n    @property\n    def nargout(self) -&gt; int:\n        \"\"\"The size of the output vector.\"\"\"\n        return self.__nargout\n\n    @property\n    def symmetric(self) -&gt; bool:\n        \"\"\"Indicate whether the operator is symmetric or not.\"\"\"\n        return self.__symmetric\n\n    @property\n    def shape(self) -&gt; Tuple[int, int]:\n        \"\"\"The shape of the operator.\"\"\"\n        return self.__shape\n\n    @property\n    def dtype(self) -&gt; npt.DTypeLike:\n        \"\"\"The data type of the operator.\"\"\"\n        return self.__dtype\n\n    @dtype.setter\n    def dtype(self, dtype):\n        self.__dtype = dtype\n\n    @property\n    def nMatvec(self) -&gt; int:\n        \"\"\"The number of products with vectors computed so far.\"\"\"\n        return self._nMatvec\n\n    def reset_counters(self):\n        \"\"\"Reset operator/vector product counter to zero.\"\"\"\n        self._nMatvec = 0\n\n    def dot(self, x):\n        \"\"\"Numpy-like dot() method.\"\"\"\n        return self.__mul__(x)\n\n    def __call__(self, *args, **kwargs):\n        # An alias for __mul__.\n        return self.__mul__(*args, **kwargs)\n\n    def __mul__(self, x):\n        raise NotImplementedError(\"Please subclass to implement __mul__.\")\n\n    def __repr__(self) -&gt; str:\n        if self.symmetric:\n            s = \"Symmetric\"\n        else:\n            s = \"Unsymmetric\"\n        s += \" &lt;\" + self.__class__.__name__ + \"&gt;\"\n        s += \" of type %s\" % self.dtype\n        s += \" with shape (%d,%d)\" % (self.nargout, self.nargin)\n        return s\n</code></pre>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.dtype","title":"<code>dtype: npt.DTypeLike</code>  <code>property</code> <code>writable</code>","text":"<p>The data type of the operator.</p>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.nMatvec","title":"<code>nMatvec: int</code>  <code>property</code>","text":"<p>The number of products with vectors computed so far.</p>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.nargin","title":"<code>nargin: int</code>  <code>property</code>","text":"<p>The size of the input vector.</p>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.nargout","title":"<code>nargout: int</code>  <code>property</code>","text":"<p>The size of the output vector.</p>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.shape","title":"<code>shape: Tuple[int, int]</code>  <code>property</code>","text":"<p>The shape of the operator.</p>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.symmetric","title":"<code>symmetric: bool</code>  <code>property</code>","text":"<p>Indicate whether the operator is symmetric or not.</p>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.dot","title":"<code>dot(x)</code>","text":"<p>Numpy-like dot() method.</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def dot(self, x):\n    \"\"\"Numpy-like dot() method.\"\"\"\n    return self.__mul__(x)\n</code></pre>"},{"location":"api_reference/base_operators/BaseLinearOperator/#brahmap.base.BaseLinearOperator.reset_counters","title":"<code>reset_counters()</code>","text":"<p>Reset operator/vector product counter to zero.</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def reset_counters(self):\n    \"\"\"Reset operator/vector product counter to zero.\"\"\"\n    self._nMatvec = 0\n</code></pre>"},{"location":"api_reference/base_operators/BlockDiagonalLinearOperator/","title":"<code>brahmap.base.BlockDiagonalLinearOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>Base class for a block-diagonal linear operator</p> <p>Parameters:</p> Name Type Description Default <code>block_list</code> <code>List[LinearOperator]</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/blkop.py</code> <pre><code>class BlockDiagonalLinearOperator(LinearOperator):\n    \"\"\"Base class for a block-diagonal linear operator\n\n    Parameters\n    ----------\n    block_list : List[LinearOperator]\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        block_list: List[LinearOperator],\n        **kwargs: Any,\n    ):\n        try:\n            for block in block_list:\n                __, __ = block.shape\n        except (TypeError, AttributeError):\n            MPI_RAISE_EXCEPTION(\n                condition=True,\n                exception=ValueError,\n                message=\"The `block_list` must be a flat list of linearoperators\",\n            )\n\n        self.__row_size = np.asarray(\n            [block.shape[0] for block in block_list], dtype=int\n        )\n        self.__col_size = np.asarray(\n            [block.shape[-1] for block in block_list], dtype=int\n        )\n\n        nargin = sum(self.__col_size)\n        nargout = sum(self.__row_size)\n        symmetric = reduce(\n            lambda x, y: x and y, [block.symmetric for block in block_list]\n        )\n        dtype = np.result_type(*[block.dtype for block in block_list])\n\n        self.__block_list = block_list\n\n        # transpose operator\n        blocks_list_transposed = [block.T for block in block_list]\n\n        matvec = partial(\n            self._mult,\n            block_list=self.block_list,\n            dtype=dtype,\n        )\n        rmatvec = partial(\n            self._mult,\n            block_list=blocks_list_transposed,\n            dtype=dtype,\n        )\n\n        super(BlockDiagonalLinearOperator, self).__init__(\n            nargin=nargin,\n            nargout=nargout,\n            symmetric=symmetric,\n            matvec=matvec,\n            rmatvec=rmatvec,\n            dtype=dtype,\n            **kwargs,\n        )\n\n    @property\n    def block_list(self) -&gt; List:\n        return self.__block_list\n\n    @property\n    def num_blocks(self) -&gt; int:\n        return len(self.block_list)\n\n    @property\n    def row_size(self) -&gt; np.ndarray:\n        return self.__row_size\n\n    @property\n    def col_size(self) -&gt; np.ndarray:\n        return self.__col_size\n\n    def __getitem__(self, idx):\n        block_range = self.block_list[idx]\n        if isinstance(idx, slice):\n            return BlockDiagonalLinearOperator(\n                block_list=block_range,\n            )\n        else:\n            return block_range\n\n    def _mult(self, vec: np.ndarray, block_list: List, dtype) -&gt; np.ndarray:\n        nrows = sum([block.shape[0] for block in block_list])\n        ncols = sum([block.shape[1] for block in block_list])\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != ncols),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimensions of this `BlockDiagonalLinearOperator` instance.\\nShape of `BlockDiagonalLinearOperator` instance: ({nrows, ncols})\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=dtype, copy=False)\n\n        prod = np.zeros(nrows, dtype=dtype)\n\n        start_row_idx = 0\n        start_col_idx = 0\n        for idx, block in enumerate(block_list):\n            end_row_idx = start_row_idx + block.shape[0]\n            end_col_idx = start_col_idx + block.shape[1]\n\n            prod[start_row_idx:end_row_idx] = block * vec[start_col_idx:end_col_idx]\n\n            start_row_idx = end_row_idx\n            start_col_idx = end_col_idx\n\n        return prod\n</code></pre>"},{"location":"api_reference/base_operators/BlockHorizontalLinearOperator/","title":"<code>brahmap.base.BlockHorizontalLinearOperator</code>","text":"<p>               Bases: <code>BlockLinearOperator</code></p> <p>A block horizontal linear operator.</p> <p>Each block must be a linear operator. The blocks must be specified as one list, e.g., <code>[A, B, C]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>List[LinearOperator]</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/blkop.py</code> <pre><code>class BlockHorizontalLinearOperator(BlockLinearOperator):\n    \"\"\"\n    A block horizontal linear operator.\n\n    Each block must be a linear operator.\n    The blocks must be specified as one list, e.g., `[A, B, C]`.\n\n    Parameters\n    ----------\n    blocks : List[LinearOperator]\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        blocks: List[LinearOperator],\n        **kwargs: Any,\n    ):\n        try:\n            for block in blocks:\n                __ = block.shape\n        except (TypeError, AttributeError):\n            raise ValueError(\"blocks should be a flattened list of operators\")\n\n        blocks = [[blk for blk in blocks]]\n\n        super(BlockHorizontalLinearOperator, self).__init__(\n            blocks=blocks, symmetric=False, **kwargs\n        )\n</code></pre>"},{"location":"api_reference/base_operators/BlockLinearOperator/","title":"<code>brahmap.base.BlockLinearOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A linear operator defined by blocks. Each block must be a linear operator.</p> <p><code>blocks</code> should be a list of lists describing the blocks row-wise. If there is only one block row, it should be specified as <code>[[b1, b2, ..., bn]]</code>, not as <code>[b1, b2, ..., bn]</code>.</p> <p>If the overall linear operator is symmetric, only its upper triangle need be specified, e.g., <code>[[A,B,C], [D,E], [F]]</code>, and the blocks on the diagonal must be square and symmetric.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>List[LinearOperator]</code> <p>description</p> required <code>symmetric</code> <code>bool</code> <p>description, by default False</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/blkop.py</code> <pre><code>class BlockLinearOperator(LinearOperator):\n    \"\"\"\n    A linear operator defined by blocks. Each block must be a linear operator.\n\n    `blocks` should be a list of lists describing the blocks row-wise.\n    If there is only one block row, it should be specified as\n    `[[b1, b2, ..., bn]]`, not as `[b1, b2, ..., bn]`.\n\n    If the overall linear operator is symmetric, only its upper triangle\n    need be specified, e.g., `[[A,B,C], [D,E], [F]]`, and the blocks on the\n    diagonal must be square and symmetric.\n\n    Parameters\n    ----------\n    blocks : List[LinearOperator]\n        _description_\n    symmetric : bool, optional\n        _description_, by default False\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        blocks: List[LinearOperator],\n        symmetric: bool = False,\n        **kwargs: Any,\n    ):\n        # If building a symmetric operator, fill in the blanks.\n        # They're just references to existing objects.\n        try:\n            for block_row in blocks:\n                for block_col in block_row:\n                    __ = block_col.shape\n        except (TypeError, AttributeError):\n            raise ValueError(\"blocks should be a nested list of operators\")\n\n        if symmetric:\n            nrow = len(blocks)\n            ncol = len(blocks[0])\n            if nrow != ncol:\n                raise ShapeError(\"Inconsistent shape.\")\n\n            for block_row in blocks:\n                if not block_row[0].symmetric:\n                    raise ValueError(\"Blocks on diagonal must be symmetric.\")\n\n            self._blocks = blocks[:]\n            for i in range(1, nrow):\n                for j in range(i - 1, -1, -1):\n                    self._blocks[i].insert(0, self._blocks[j][i].T)\n\n        else:\n            self._blocks = blocks\n\n        log = kwargs.get(\"logger\", null_log)\n        log.debug(\"Building new BlockLinearOperator\")\n\n        nargins = [[blk.shape[-1] for blk in row] for row in self._blocks]\n        log.debug(\"nargins = \" + repr(nargins))\n        nargins_by_row = [nargin[0] for nargin in nargins]\n        if min(nargins_by_row) != max(nargins_by_row):\n            raise ShapeError(\"Inconsistent block shapes\")\n\n        nargouts = [[blk.shape[0] for blk in row] for row in self._blocks]\n        log.debug(\"nargouts = \" + repr(nargouts))\n        for row in nargouts:\n            if min(row) != max(row):\n                raise ShapeError(\"Inconsistent block shapes\")\n\n        nargin = sum(nargins[0])\n        nargout = sum([out[0] for out in nargouts])\n\n        # Create blocks of transpose operator.\n        blocksT = list(map(lambda *row: [blk.T for blk in row], *self._blocks))\n\n        def blk_matvec(x, blks):\n            nargins = [[blk.shape[-1] for blk in blkrow] for blkrow in blks]\n            nargouts = [[blk.shape[0] for blk in blkrow] for blkrow in blks]\n            nargin = sum(nargins[0])\n            nargout = sum([out[0] for out in nargouts])\n            nx = len(x)\n            self.logger.debug(\"Multiplying with a vector of size %d\" % nx)\n            self.logger.debug(\"nargin=%d, nargout=%d\" % (nargin, nargout))\n            if nx != nargin:\n                raise ShapeError(\"Multiplying with vector of wrong shape.\")\n\n            result_type = np.result_type(self.dtype, x.dtype)\n            y = np.zeros(nargout, dtype=result_type)\n\n            nblk_row = len(blks)\n            nblk_col = len(blks[0])\n\n            row_start = col_start = 0\n            for row in range(nblk_row):\n                row_end = row_start + nargouts[row][0]\n                yout = y[row_start:row_end]\n                for col in range(nblk_col):\n                    col_end = col_start + nargins[0][col]\n                    xin = x[col_start:col_end]\n                    B = blks[row][col]\n                    yout[:] += B * xin\n                    col_start = col_end\n                row_start = row_end\n                col_start = 0\n\n            return y\n\n        flat_blocks = list(itertools.chain(*blocks))\n        blk_dtypes = [blk.dtype for blk in flat_blocks]\n        op_dtype = np.result_type(*blk_dtypes)\n\n        super(BlockLinearOperator, self).__init__(\n            nargin,\n            nargout,\n            symmetric=symmetric,\n            matvec=lambda x: blk_matvec(x, self._blocks),\n            rmatvec=lambda x: blk_matvec(x, blocksT),\n            dtype=op_dtype,\n            **kwargs,\n        )\n\n        self.H._blocks = blocksT\n\n    @property\n    def blocks(self):\n        \"\"\"The list of blocks defining the block operator.\"\"\"\n        return self._blocks\n\n    def __getitem__(self, indices):\n        blks = np.matrix(self._blocks, dtype=object)[indices]\n        # If indexing narrowed it down to a single block, return it.\n        if isinstance(blks, BaseLinearOperator):\n            return blks\n        # Otherwise, we have a matrix of blocks.\n        return BlockLinearOperator(blks.tolist(), symmetric=False)\n\n    def __contains__(self, op):\n        flat_blocks = list(itertools.chain(*self.blocks))\n        return op in flat_blocks\n\n    def __iter__(self):\n        for block in self._blocks:\n            yield block\n</code></pre>"},{"location":"api_reference/base_operators/BlockLinearOperator/#brahmap.base.BlockLinearOperator.blocks","title":"<code>blocks</code>  <code>property</code>","text":"<p>The list of blocks defining the block operator.</p>"},{"location":"api_reference/base_operators/BlockVerticalLinearOperator/","title":"<code>brahmap.base.BlockVerticalLinearOperator</code>","text":"<p>               Bases: <code>BlockLinearOperator</code></p> <p>A block vertical linear operator.</p> <p>Each block must be a linear operator. The blocks must be specified as one list, e.g., <code>[A, B, C]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>List[LinearOperator]</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/blkop.py</code> <pre><code>class BlockVerticalLinearOperator(BlockLinearOperator):\n    \"\"\"\n    A block vertical linear operator.\n\n    Each block must be a linear operator.\n    The blocks must be specified as one list, e.g., `[A, B, C]`.\n\n    Parameters\n    ----------\n    blocks : List[LinearOperator]\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        blocks: List[LinearOperator],\n        **kwargs: Any,\n    ):\n        try:\n            for block in blocks:\n                __ = block.shape\n        except (TypeError, AttributeError):\n            raise ValueError(\"blocks should be a flattened list of operators\")\n\n        blocks = [[blk] for blk in blocks]\n\n        super(BlockVerticalLinearOperator, self).__init__(\n            blocks=blocks, symmetric=False, **kwargs\n        )\n</code></pre>"},{"location":"api_reference/base_operators/DiagonalOperator/","title":"<code>brahmap.base.DiagonalOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A linear operator for a diagonal matrix</p> <p>Parameters:</p> Name Type Description Default <code>diag</code> <code>ndarray</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/linop.py</code> <pre><code>class DiagonalOperator(LinearOperator):\n    \"\"\"A linear operator for a diagonal matrix\n\n    Parameters\n    ----------\n    diag : np.ndarray\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(self, diag: np.ndarray, **kwargs: Any):\n        if \"symmetric\" in kwargs:\n            kwargs.pop(\"symmetric\")\n        if \"matvec\" in kwargs:\n            kwargs.pop(\"matvec\")\n        if \"dtype\" in kwargs:\n            kwargs.pop(\"dtype\")\n\n        self.diag = np.asarray(diag)\n        if self.diag.ndim != 1:\n            msg = \"diag array must be 1-d\"\n            raise ValueError(msg)\n\n        super(DiagonalOperator, self).__init__(\n            self.diag.shape[0],\n            self.diag.shape[0],\n            symmetric=True,\n            matvec=lambda x: self.diag * x,\n            dtype=self.diag.dtype,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_reference/base_operators/IdentityOperator/","title":"<code>brahmap.base.IdentityOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A linear operator for the identity matrix of size <code>nargin</code></p> <p>Parameters:</p> Name Type Description Default <code>nargin</code> <code>int</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/linop.py</code> <pre><code>class IdentityOperator(LinearOperator):\n    \"\"\"A linear operator for the identity matrix of size `nargin`\n\n    Parameters\n    ----------\n    nargin : int\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(self, nargin: int, **kwargs: Any):\n        if \"symmetric\" in kwargs:\n            kwargs.pop(\"symmetric\")\n        if \"matvec\" in kwargs:\n            kwargs.pop(\"matvec\")\n\n        super(IdentityOperator, self).__init__(\n            nargin, nargin, symmetric=True, matvec=lambda x: x, **kwargs\n        )\n</code></pre>"},{"location":"api_reference/base_operators/InvNoiseCovLinearOperator/","title":"<code>brahmap.base.InvNoiseCovLinearOperator</code>","text":"<p>               Bases: <code>NoiseCovLinearOperator</code></p> <p>Base class for inverse noise covariance operators</p> <p>Parameters:</p> Name Type Description Default <code>nargin</code> <code>int</code> <p>description</p> required <code>matvec</code> <code>int</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"covariance\"</p> <code>'covariance'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/noise_ops.py</code> <pre><code>class InvNoiseCovLinearOperator(NoiseCovLinearOperator):\n    \"\"\"Base class for inverse noise covariance operators\n\n    Parameters\n    ----------\n    nargin : int\n        _description_\n    matvec : int\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"covariance\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        nargin: int,\n        matvec: int,\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"covariance\",\n        dtype: DTypeFloat = np.float64,\n        **kwargs: Any,\n    ):\n        super(InvNoiseCovLinearOperator, self).__init__(\n            nargin,\n            matvec,\n            input_type,\n            dtype,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_reference/base_operators/InverseLO/","title":"<code>brahmap.base.InverseLO</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>Construct the inverse operator of a matrix <code>A</code>, as a linear operator.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>_type_</code> <p>description</p> required <code>method</code> <code>_type_</code> <p>description, by default None</p> <code>None</code> <code>preconditioner</code> <code>_type_</code> <p>description, by default None</p> <code>None</code> Source code in <code>brahmap/base/linop.py</code> <pre><code>class InverseLO(LinearOperator):\n    r\"\"\"\n    Construct the inverse operator of a matrix `A`, as a linear operator.\n\n    Parameters\n    ----------\n    A : _type_\n        _description_\n    method : _type_, optional\n        _description_, by default None\n    preconditioner : _type_, optional\n        _description_, by default None\n\n    \"\"\"\n\n    def __init__(self, A, method=None, preconditioner=None):\n        super(InverseLO, self).__init__(\n            nargin=A.shape[0], nargout=A.shape[1], matvec=self.mult, symmetric=True\n        )\n        self.A = A\n        self.__method = method\n        self.__preconditioner = preconditioner\n        self.__converged = None\n\n    def mult(self, x):\n        r\"\"\"\n        It returns  :math:`y=A^{-1}x` by solving the linear system :math:`Ay=x`\n        with a certain :mod:`scipy` routine (e.g. :func:`scipy.sparse.linalg.cg`)\n        defined above as ``method``.\n        \"\"\"\n\n        y, info = self.method(self.A, x, M=self.preconditioner)\n        self.isconverged(info)\n        return y\n\n    def isconverged(self, info):\n        r\"\"\"\n        It returns a Boolean value  depending on the\n        exit status of the solver.\n\n        **Parameters**\n\n        - ``info`` : {int}\n            output of the solver method (usually :func:`scipy.sparse.cg`).\n        \"\"\"\n        self.__converged = info\n        if info == 0:\n            return True\n        else:\n            return False\n\n    @property\n    def method(self):\n        r\"\"\"\n        The method to compute the inverse of A. \\\n        It can be any :mod:`scipy.sparse.linalg` solver, namely :func:`scipy.sparse.linalg.cg`,\n        :func:`scipy.sparse.linalg.bicg`, etc.\n\n        \"\"\"\n        return self.__method\n\n    @property\n    def converged(self):\n        r\"\"\"\n        provides convergence information:\n\n        - 0 : successful exit;\n        - &gt;0 : convergence to tolerance not achieved, number of iterations;\n        - &lt;0 : illegal input or breakdown.\n\n        \"\"\"\n        return self.__converged\n\n    @property\n    def preconditioner(self):\n        \"\"\"\n        Preconditioner for the solver.\n        \"\"\"\n        return self.__preconditioner\n</code></pre>"},{"location":"api_reference/base_operators/InverseLO/#brahmap.base.InverseLO.converged","title":"<code>converged</code>  <code>property</code>","text":"<p>provides convergence information:</p> <ul> <li>0 : successful exit;</li> <li> <p>0 : convergence to tolerance not achieved, number of iterations;</p> </li> <li>&lt;0 : illegal input or breakdown.</li> </ul>"},{"location":"api_reference/base_operators/InverseLO/#brahmap.base.InverseLO.method","title":"<code>method</code>  <code>property</code>","text":"<p>The method to compute the inverse of A. \\ It can be any :mod:<code>scipy.sparse.linalg</code> solver, namely :func:<code>scipy.sparse.linalg.cg</code>, :func:<code>scipy.sparse.linalg.bicg</code>, etc.</p>"},{"location":"api_reference/base_operators/InverseLO/#brahmap.base.InverseLO.preconditioner","title":"<code>preconditioner</code>  <code>property</code>","text":"<p>Preconditioner for the solver.</p>"},{"location":"api_reference/base_operators/InverseLO/#brahmap.base.InverseLO.isconverged","title":"<code>isconverged(info)</code>","text":"<p>It returns a Boolean value  depending on the exit status of the solver.</p> <p>Parameters</p> <ul> <li><code>info</code> : {int}     output of the solver method (usually :func:<code>scipy.sparse.cg</code>).</li> </ul> Source code in <code>brahmap/base/linop.py</code> <pre><code>def isconverged(self, info):\n    r\"\"\"\n    It returns a Boolean value  depending on the\n    exit status of the solver.\n\n    **Parameters**\n\n    - ``info`` : {int}\n        output of the solver method (usually :func:`scipy.sparse.cg`).\n    \"\"\"\n    self.__converged = info\n    if info == 0:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/base_operators/InverseLO/#brahmap.base.InverseLO.mult","title":"<code>mult(x)</code>","text":"<p>It returns  :math:<code>y=A^{-1}x</code> by solving the linear system :math:<code>Ay=x</code> with a certain :mod:<code>scipy</code> routine (e.g. :func:<code>scipy.sparse.linalg.cg</code>) defined above as <code>method</code>.</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def mult(self, x):\n    r\"\"\"\n    It returns  :math:`y=A^{-1}x` by solving the linear system :math:`Ay=x`\n    with a certain :mod:`scipy` routine (e.g. :func:`scipy.sparse.linalg.cg`)\n    defined above as ``method``.\n    \"\"\"\n\n    y, info = self.method(self.A, x, M=self.preconditioner)\n    self.isconverged(info)\n    return y\n</code></pre>"},{"location":"api_reference/base_operators/LinearOperator/","title":"<code>brahmap.base.LinearOperator</code>","text":"<p>               Bases: <code>BaseLinearOperator</code></p> <p>A generic linear operator class.</p> <p>A linear operator constructed from a matrix-vector multiplication <code>matvec</code>, \\(x \\mapsto A(x)=Ax\\) and possibly with a transposed-matrix-vector operation <code>rmatvec</code>, \\(x \\mapsto A(x)=A^T x\\). If <code>symmetric</code> is <code>True</code>, <code>rmatvec</code> is ignored. All other keyword arguments are passed directly to the superclass.</p> <p>Parameters:</p> Name Type Description Default <code>nargin</code> <code>int</code> <p>Size of the input vector \\(x\\)</p> required <code>nargout</code> <code>int</code> <p>Size of the output vector \\(A(x)\\)</p> required <code>matvec</code> <code>Callable</code> <p>A function that defines the matrix-vector product \\(x \\mapsto A(x)=Ax\\)</p> required <code>rmatvec</code> <code>Optional[Callable]</code> <p>A function that defines the transposed-matrix-vector product \\(x \\mapsto A(x)=A^T x\\), by default <code>None</code></p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Extra keywords arguments</p> <code>{}</code> Source code in <code>brahmap/base/linop.py</code> <pre><code>class LinearOperator(BaseLinearOperator):\n    \"\"\"\n    A generic linear operator class.\n\n    A linear operator constructed from a matrix-vector multiplication `matvec`,\n    $x \\\\mapsto A(x)=Ax$ and possibly with a transposed-matrix-vector\n    operation `rmatvec`, $x \\\\mapsto A(x)=A^T x$. If `symmetric` is `True`,\n    `rmatvec` is ignored. All other keyword arguments are passed directly to\n    the superclass.\n\n    Parameters\n    ----------\n    nargin : int\n        Size of the input vector $x$\n    nargout : int\n        Size of the output vector $A(x)$\n    matvec : Callable\n        A function that defines the matrix-vector product $x \\\\mapsto A(x)=Ax$\n    rmatvec : Optional[Callable], optional\n        A function that defines the transposed-matrix-vector product\n        $x \\\\mapsto A(x)=A^T x$, by default `None`\n    **kwargs : Any\n        Extra keywords arguments\n    \"\"\"\n\n    def __init__(\n        self,\n        nargin: int,\n        nargout: int,\n        matvec: Callable,\n        rmatvec: Optional[Callable] = None,\n        **kwargs,\n    ):\n        super(LinearOperator, self).__init__(\n            nargin,\n            nargout,\n            **kwargs,\n        )\n        adjoint_of = kwargs.get(\"adjoint_of\", None) or kwargs.get(\"transpose_of\", None)\n        rmatvec = rmatvec or kwargs.get(\"matvec_transp\", None)\n\n        self.__matvec = matvec\n\n        if self.symmetric:\n            self.__H = self\n        else:\n            if adjoint_of is None:\n                if rmatvec is not None:\n                    # Create 'pointer' to transpose operator.\n                    self.__H = LinearOperator(\n                        nargout,\n                        nargin,\n                        matvec=rmatvec,\n                        rmatvec=matvec,\n                        adjoint_of=self,\n                        **kwargs,\n                    )\n                else:\n                    self.__H = None\n            else:\n                # Use operator supplied as transpose operator.\n                if isinstance(adjoint_of, BaseLinearOperator):\n                    self.__H = adjoint_of\n                else:\n                    msg = (\n                        \"kwarg adjoint_of / transpose_of must be of type\"\n                        \" LinearOperator.\"\n                    )\n                    msg += \" Got \" + str(adjoint_of.__class__)\n                    raise ValueError(msg)\n\n    @property\n    def T(self):\n        \"\"\"The transpose operator\"\"\"\n        return self.__H\n\n    @property\n    def H(self):\n        \"\"\"The adjoint operator\"\"\"\n        return self.__H\n\n    def matvec(self, x):\n        \"\"\"\n        Matrix-vector multiplication.\n\n        The matvec property encapsulates the `matvec` routine specified at\n        construct time, to ensure the consistency of the input and output\n        arrays with the operator's shape.\n        \"\"\"\n        x = np.asanyarray(x)\n        M, N = self.shape\n\n        # check input data consistency\n        N = int(N)\n        try:\n            x = x.reshape(N)\n        except ValueError:\n            msg = (\n                \"The size of the input array is incompatible with the \"\n                \"operator dimensions\\n\"\n                f\"size of the input array: {len(x)}\\n\"\n                f\"shape of the operator: {self.shape}\"\n            )\n            raise ValueError(msg)\n\n        y = self.__matvec(x)\n\n        # check output data consistency\n        M = int(M)\n        try:\n            y = y.reshape(M)\n        except ValueError:\n            msg = (\n                \"The size of the output array is incompatible with the \"\n                \"operator dimensions\\n\"\n                f\"size of the output array: {len(y)}\\n\"\n                f\"shape of the operator: {self.shape}\"\n            )\n            raise ValueError(msg)\n\n        return y\n\n    def to_array(self) -&gt; np.ndarray:\n        \"\"\"Returns the dense form of the linear operator as a 2D NumPy array\n\n        !!! Warning\n\n            This method first allocates a NumPy array of shape `self.shape`\n            and data-type `self.dtype`, and then fills them with numbers. As\n            such it can occupy an enormous amount of memory. Don't use it\n            unless you understand the risk!\n        \"\"\"\n        n, m = self.shape\n        H = np.empty((n, m), dtype=self.dtype)\n        ej = np.zeros(m, dtype=self.dtype)\n        for j in range(m):\n            ej[j] = 1.0\n            H[:, j] = self * ej\n            ej[j] = 0.0\n        return H\n\n    def __mul_scalar(self, x):\n        # Product between a linear operator and a scalar\n        result_type = np.result_type(self.dtype, type(x))\n\n        if x != 0:\n\n            def matvec(y):\n                return x * (self(y))\n\n            def rmatvec(y):\n                return x * (self.H(y))\n\n            return LinearOperator(\n                self.nargin,\n                self.nargout,\n                symmetric=self.symmetric,\n                matvec=matvec,\n                rmatvec=rmatvec,\n                dtype=result_type,\n            )\n        else:\n            return ZeroOperator(self.nargin, self.nargout, dtype=result_type)\n\n    def __mul_linop(self, op):\n        # Product between two linear operators\n        if self.nargin != op.nargout:\n            msg = (\n                \"Cannot multiply the two operators together\\n\"\n                f\"shape of the first operator: {self.shape}\\n\"\n                f\"shape of the second operator: {op.shape}\"\n            )\n            raise ShapeError(msg)\n\n        def matvec(x):\n            return self(op(x))\n\n        def rmatvec(x):\n            return op.T(self.H(x))\n\n        result_type = np.result_type(self.dtype, op.dtype)\n\n        return LinearOperator(\n            op.nargin,\n            self.nargout,\n            symmetric=False,  # Generally.\n            matvec=matvec,\n            rmatvec=rmatvec,\n            dtype=result_type,\n        )\n\n    def __mul_vector(self, x):\n        # Product between a linear operator and a vector\n        self._nMatvec += 1\n        result_type = np.result_type(self.dtype, x.dtype)\n        return self.matvec(x).astype(result_type, copy=False)\n\n    def __mul__(self, x):\n        # Returns a linear operator if x is a scalar or a linear operator\n        # Returns a vector if x is an array\n        if isinstance(x, numbers.Number):\n            return self.__mul_scalar(x)\n        elif isinstance(x, BaseLinearOperator):\n            return self.__mul_linop(x)\n        elif isinstance(x, np.ndarray):\n            return self.__mul_vector(x)\n        else:\n            raise ValueError(\"Invalid multiplier! Cannot multiply\")\n\n    def __rmul__(self, x):\n        if np.isscalar(x):\n            return self.__mul__(x)\n        raise ValueError(\"Invalid operation! Cannot multiply\")\n\n    def __add__(self, other):\n        if not isinstance(other, BaseLinearOperator):\n            raise ValueError(\"Invalid operation! Cannot add\")\n        if self.shape != other.shape:\n            msg = (\n                \"Cannot add the two operators together\\n\"\n                f\"shape of the first operator: {self.shape}\\n\"\n                f\"shape of the second operator: {other.shape}\"\n            )\n            raise ShapeError(msg)\n\n        def matvec(x):\n            return self(x) + other(x)\n\n        def rmatvec(x):\n            return self.H(x) + other.T(x)\n\n        result_type = np.result_type(self.dtype, other.dtype)\n\n        return LinearOperator(\n            self.nargin,\n            self.nargout,\n            symmetric=self.symmetric and other.symmetric,\n            matvec=matvec,\n            rmatvec=rmatvec,\n            dtype=result_type,\n        )\n\n    def __neg__(self):\n        return self * (-1)\n\n    def __sub__(self, other):\n        if not isinstance(other, BaseLinearOperator):\n            raise ValueError(\"Invalid operation! Cannot subtract\")\n        if self.shape != other.shape:\n            msg = (\n                \"Cannot subtract one operator from the other\\n\"\n                f\"shape of the first operator: {self.shape}\\n\"\n                f\"shape of the second operator: {other.shape}\"\n            )\n            raise ShapeError(msg)\n\n        def matvec(x):\n            return self(x) - other(x)\n\n        def rmatvec(x):\n            return self.H(x) - other.T(x)\n\n        result_type = np.result_type(self.dtype, other.dtype)\n\n        return LinearOperator(\n            self.nargin,\n            self.nargout,\n            symmetric=self.symmetric and other.symmetric,\n            matvec=matvec,\n            rmatvec=rmatvec,\n            dtype=result_type,\n        )\n\n    def __truediv__(self, other):\n        if np.isscalar(other):\n            return self * (1 / other)\n        else:\n            raise ValueError(\"Invalid operation! Cannot divide\")\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            raise ValueError(\"Can only raise to integer power\")\n        if other &lt; 0:\n            raise ValueError(\"Can only raise to nonnegative power\")\n        if self.nargin != self.nargout:\n            raise ShapeError(\"Can only raise square operators to a power\")\n        if other == 0:\n            return IdentityOperator(self.nargin)\n        if other == 1:\n            return self\n        return self * self ** (other - 1)\n</code></pre>"},{"location":"api_reference/base_operators/LinearOperator/#brahmap.base.LinearOperator.H","title":"<code>H</code>  <code>property</code>","text":"<p>The adjoint operator</p>"},{"location":"api_reference/base_operators/LinearOperator/#brahmap.base.LinearOperator.T","title":"<code>T</code>  <code>property</code>","text":"<p>The transpose operator</p>"},{"location":"api_reference/base_operators/LinearOperator/#brahmap.base.LinearOperator.matvec","title":"<code>matvec(x)</code>","text":"<p>Matrix-vector multiplication.</p> <p>The matvec property encapsulates the <code>matvec</code> routine specified at construct time, to ensure the consistency of the input and output arrays with the operator's shape.</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def matvec(self, x):\n    \"\"\"\n    Matrix-vector multiplication.\n\n    The matvec property encapsulates the `matvec` routine specified at\n    construct time, to ensure the consistency of the input and output\n    arrays with the operator's shape.\n    \"\"\"\n    x = np.asanyarray(x)\n    M, N = self.shape\n\n    # check input data consistency\n    N = int(N)\n    try:\n        x = x.reshape(N)\n    except ValueError:\n        msg = (\n            \"The size of the input array is incompatible with the \"\n            \"operator dimensions\\n\"\n            f\"size of the input array: {len(x)}\\n\"\n            f\"shape of the operator: {self.shape}\"\n        )\n        raise ValueError(msg)\n\n    y = self.__matvec(x)\n\n    # check output data consistency\n    M = int(M)\n    try:\n        y = y.reshape(M)\n    except ValueError:\n        msg = (\n            \"The size of the output array is incompatible with the \"\n            \"operator dimensions\\n\"\n            f\"size of the output array: {len(y)}\\n\"\n            f\"shape of the operator: {self.shape}\"\n        )\n        raise ValueError(msg)\n\n    return y\n</code></pre>"},{"location":"api_reference/base_operators/LinearOperator/#brahmap.base.LinearOperator.to_array","title":"<code>to_array() -&gt; np.ndarray</code>","text":"<p>Returns the dense form of the linear operator as a 2D NumPy array</p> <p>Warning</p> <p>This method first allocates a NumPy array of shape <code>self.shape</code> and data-type <code>self.dtype</code>, and then fills them with numbers. As such it can occupy an enormous amount of memory. Don't use it unless you understand the risk!</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def to_array(self) -&gt; np.ndarray:\n    \"\"\"Returns the dense form of the linear operator as a 2D NumPy array\n\n    !!! Warning\n\n        This method first allocates a NumPy array of shape `self.shape`\n        and data-type `self.dtype`, and then fills them with numbers. As\n        such it can occupy an enormous amount of memory. Don't use it\n        unless you understand the risk!\n    \"\"\"\n    n, m = self.shape\n    H = np.empty((n, m), dtype=self.dtype)\n    ej = np.zeros(m, dtype=self.dtype)\n    for j in range(m):\n        ej[j] = 1.0\n        H[:, j] = self * ej\n        ej[j] = 0.0\n    return H\n</code></pre>"},{"location":"api_reference/base_operators/MatrixLinearOperator/","title":"<code>brahmap.base.MatrixLinearOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A linear operator for a numpy matrix</p> <p>A linear operator wrapping the multiplication with a matrix and its transpose (real) or conjugate transpose (complex). The operator's dtype is the same as the specified <code>matrix</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/linop.py</code> <pre><code>class MatrixLinearOperator(LinearOperator):\n    \"\"\"A linear operator for a numpy matrix\n\n    A linear operator wrapping the multiplication with a matrix and its\n    transpose (real) or conjugate transpose (complex). The operator's dtype\n    is the same as the specified `matrix` argument.\n\n    Parameters\n    ----------\n    matrix : np.ndarray\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(self, matrix: np.ndarray, **kwargs: Any):\n        if \"symmetric\" in kwargs:\n            kwargs.pop(\"symmetric\")\n        if \"matvec\" in kwargs:\n            kwargs.pop(\"matvec\")\n        if \"dtype\" in kwargs:\n            kwargs.pop(\"dtype\")\n\n        if not hasattr(matrix, \"shape\"):\n            matrix = np.asanyarray(matrix)\n\n        if matrix.ndim != 2:\n            msg = \"matrix must be 2-d (shape can be [M, N], [M, 1] or [1, N])\"\n            raise ValueError(msg)\n\n        matvec = matrix.dot\n        iscomplex = np.iscomplexobj(matrix)\n\n        if matrix.shape[0] == matrix.shape[1]:\n            symmetric = np.all(matrix == matrix.conj().T)\n        else:\n            symmetric = False\n\n        if not symmetric:\n            rmatvec = matrix.conj().T.dot if iscomplex else matrix.T.dot\n        else:\n            rmatvec = None\n\n        super(MatrixLinearOperator, self).__init__(\n            matrix.shape[1],\n            matrix.shape[0],\n            symmetric=symmetric,\n            matvec=matvec,\n            rmatvec=rmatvec,\n            dtype=matrix.dtype,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_reference/base_operators/NoiseCovLinearOperator/","title":"<code>brahmap.base.NoiseCovLinearOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>Base class for noise covariance operators</p> <p>Parameters:</p> Name Type Description Default <code>nargin</code> <code>int</code> <p>description</p> required <code>matvec</code> <code>int</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"covariance\"</p> <code>'covariance'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/noise_ops.py</code> <pre><code>class NoiseCovLinearOperator(LinearOperator):\n    \"\"\"Base class for noise covariance operators\n\n    Parameters\n    ----------\n    nargin : int\n        _description_\n    matvec : int\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"covariance\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(\n        self,\n        nargin: int,\n        matvec: int,\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"covariance\",\n        dtype: DTypeFloat = np.float64,\n        **kwargs: Any,\n    ):\n        MPI_RAISE_EXCEPTION(\n            condition=(input_type not in [\"covariance\", \"power_spectrum\"]),\n            exception=ValueError,\n            message=\"Please provide only one of `covariance` or `power_spectrum`\",\n        )\n\n        self.__size = nargin\n\n        super(NoiseCovLinearOperator, self).__init__(\n            nargin=nargin,\n            nargout=nargin,\n            matvec=matvec,\n            symmetric=True,\n            dtype=dtype,\n            **kwargs,\n        )\n\n    @property\n    def size(self) -&gt; int:\n        return self.__size\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        MPI_RAISE_EXCEPTION(\n            condition=True,\n            exception=NotImplementedError,\n            message=\"Please subclass to implement `diag`\",\n        )\n\n    def get_inverse(self) -&gt; \"InvNoiseCovLinearOperator\":\n        MPI_RAISE_EXCEPTION(\n            condition=True,\n            exception=NotImplementedError,\n            message=\"Please subclass to implement `get_inverse()`\",\n        )\n</code></pre>"},{"location":"api_reference/base_operators/ReducedLinearOperator/","title":"<code>brahmap.base.ReducedLinearOperator</code>","text":"<p>Implements reduction of a linear operator (non symmetrical).</p> <p>Reduces a linear operator by limiting its input to <code>col_indices</code> and its output to <code>row_indices</code>.</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def ReducedLinearOperator(op, row_indices, col_indices):\n    \"\"\"\n    Implements reduction of a linear operator (non symmetrical).\n\n    Reduces a linear operator by limiting its input to `col_indices` and its\n    output to `row_indices`.\n\n    \"\"\"\n\n    nargin, nargout = len(col_indices), len(row_indices)\n    m, n = op.shape  # Shape of non-reduced operator.\n\n    def matvec(x):\n        z = np.zeros(n, dtype=x.dtype)\n        z[col_indices] = x[:]\n        y = op * z\n        return y[row_indices]\n\n    def rmatvec(x):\n        z = np.zeros(m, dtype=x.dtype)\n        z[row_indices] = x[:]\n        y = op.H * z\n        return y[col_indices]\n\n    return LinearOperator(\n        nargin, nargout, matvec=matvec, symmetric=False, rmatvec=rmatvec\n    )\n</code></pre>"},{"location":"api_reference/base_operators/SymmetricallyReducedLinearOperator/","title":"<code>brahmap.base.SymmetricallyReducedLinearOperator</code>","text":"<p>Implements reduction of a linear operator (symmetrical).</p> <p>Reduces a linear operator symmetrically by reducing boths its input and output to <code>indices</code>.</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def SymmetricallyReducedLinearOperator(op, indices):\n    \"\"\"\n    Implements reduction of a linear operator (symmetrical).\n\n    Reduces a linear operator symmetrically by reducing boths its input and\n    output to `indices`.\n\n    \"\"\"\n\n    nargin = len(indices)\n    m, n = op.shape  # Shape of non-reduced operator.\n\n    def matvec(x):\n        z = np.zeros(n, dtype=x.dtype)\n        z[indices] = x[:]\n        y = op * z\n        return y[indices]\n\n    def rmatvec(x):\n        z = np.zeros(m, dtype=x.dtype)\n        z[indices] = x[:]\n        y = op * z\n        return y[indices]\n\n    return LinearOperator(\n        nargin, nargin, matvec=matvec, symmetric=op.symmetric, rmatvec=rmatvec\n    )\n</code></pre>"},{"location":"api_reference/base_operators/ZeroOperator/","title":"<code>brahmap.base.ZeroOperator</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>A linear operator for a zero matrix of shape <code>(nargout, nargin)</code></p> <p>Parameters:</p> Name Type Description Default <code>nargin</code> <code>int</code> <p>description</p> required <code>nargout</code> <code>int</code> <p>description</p> required <code>**kwargs</code> <code>Any</code> <p>description</p> <code>{}</code> Source code in <code>brahmap/base/linop.py</code> <pre><code>class ZeroOperator(LinearOperator):\n    \"\"\"A linear operator for a zero matrix of shape `(nargout, nargin)`\n\n    Parameters\n    ----------\n    nargin : int\n        _description_\n    nargout : int\n        _description_\n    **kwargs: Any\n        _description_\n    \"\"\"\n\n    def __init__(self, nargin: int, nargout: int, **kwargs: Any):\n        if \"matvec\" in kwargs:\n            kwargs.pop(\"matvec\")\n        if \"rmatvec\" in kwargs:\n            kwargs.pop(\"rmatvec\")\n\n        def matvec(x):\n            if x.shape != (nargin,):\n                msg = \"Input has shape \" + str(x.shape)\n                msg += \" instead of (%d,)\" % self.nargin\n                raise ValueError(msg)\n            return np.zeros(nargout)\n\n        def rmatvec(x):\n            if x.shape != (nargout,):\n                msg = \"Input has shape \" + str(x.shape)\n                msg += \" instead of (%d,)\" % self.nargout\n                raise ValueError(msg)\n            return np.zeros(nargin)\n\n        super(ZeroOperator, self).__init__(\n            nargin, nargout, matvec=matvec, rmatvec=rmatvec, **kwargs\n        )\n</code></pre>"},{"location":"api_reference/base_operators/aslinearoperator/","title":"<code>brahmap.base.aslinearoperator</code>","text":"<p>Returns A as a LinearOperator.</p> <p>'A' may be any of the following types: - linop.LinearOperator - scipy.LinearOperator - ndarray - matrix - sparse matrix (e.g. csr_matrix, lil_matrix, etc.) - any object with .shape and .matvec attributes</p> <p>See the <code>LinearOperator</code> documentation for additonal information.</p> Source code in <code>brahmap/base/linop.py</code> <pre><code>def aslinearoperator(A):\n    \"\"\"Returns A as a LinearOperator.\n\n    'A' may be any of the following types:\n    - linop.LinearOperator\n    - scipy.LinearOperator\n    - ndarray\n    - matrix\n    - sparse matrix (e.g. csr_matrix, lil_matrix, etc.)\n    - any object with .shape and .matvec attributes\n\n    See the `LinearOperator` documentation for additonal information.\n    \"\"\"\n    if isinstance(A, LinearOperator):\n        return A\n\n    try:\n        import numpy as np\n\n        if isinstance(A, np.ndarray) or isinstance(A, np.matrix):\n            return MatrixLinearOperator(A)\n    except ImportError:\n        pass\n\n    try:\n        import scipy.sparse as ssp\n\n        if ssp.isspmatrix(A):\n            return MatrixLinearOperator(A)\n    except ImportError:\n        pass\n\n    if hasattr(A, \"shape\"):\n        nargout, nargin = A.shape\n        matvec = None\n        rmatvec = None\n        dtype = None\n        symmetric = False\n        if hasattr(A, \"matvec\"):\n            matvec = A.matvec\n            if hasattr(A, \"rmatvec\"):\n                rmatvec = A.rmatvec\n            elif hasattr(A, \"matvec_transp\"):\n                rmatvec = A.matvec_transp\n            if hasattr(A, \"dtype\"):\n                dtype = A.dtype\n            if hasattr(A, \"symmetric\"):\n                symmetric = A.symmetric\n        elif hasattr(A, \"__mul__\"):\n\n            def matvec(x):\n                return A * x\n\n            if hasattr(A, \"__rmul__\"):\n\n                def rmatvec(x):\n                    return x * A\n\n            if hasattr(A, \"dtype\"):\n                dtype = A.dtype\n            try:\n                symmetric = A.isSymmetric()\n            except Exception:\n                symmetric = False\n        return LinearOperator(\n            nargin,\n            nargout,\n            symmetric=symmetric,\n            matvec=matvec,\n            rmatvec=rmatvec,\n            dtype=dtype,\n        )\n    else:\n        raise TypeError(\"unsupported object type\")\n</code></pre>"},{"location":"api_reference/core/","title":"Core Interface","text":""},{"location":"api_reference/core/#data-pre-processing","title":"Data pre-processing","text":"<ul> <li><code>SolverType</code></li> <li><code>ProcessTimeSamples</code></li> </ul>"},{"location":"api_reference/core/#linear-operators-for-map-making","title":"Linear operators for map-making","text":"<ul> <li><code>PointingLO</code></li> <li><code>BlockDiagonalPreconditionerLO</code></li> </ul>"},{"location":"api_reference/core/#noise-covariance-and-their-inverse-operators","title":"Noise covariance (and their inverse) operators","text":"<ul> <li><code>NoiseCovLO_Diagonal</code></li> <li><code>NoiseCovLO_Circulant</code></li> <li><code>NoiseCovLO_Toeplitz01</code></li> <li><code>BlockDiagNoiseCovLO</code></li> <li><code>InvNoiseCovLO_Diagonal</code></li> <li><code>InvNoiseCovLO_Circulant</code></li> <li><code>InvNoiseCovLO_Toeplitz01</code></li> <li><code>BlockDiagInvNoiseCovLO</code></li> </ul>"},{"location":"api_reference/core/#gls-map-making-functions-and-tools","title":"GLS map-making functions and tools","text":"<ul> <li><code>GLSParameters</code></li> <li><code>compute_GLS_maps_from_PTS</code></li> <li><code>compute_GLS_maps</code></li> <li><code>separate_map_vectors</code></li> <li><code>GLSResult</code></li> </ul>"},{"location":"api_reference/core/BlockDiagInvNoiseCovLO/","title":"<code>brahmap.core.BlockDiagInvNoiseCovLO</code>","text":"<p>               Bases: <code>BlockDiagNoiseCovLO</code></p> <p>Linear operator for block-diagonal inverse noise covariance</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>_type_</code> <p>description</p> required <code>block_size</code> <code>Union[ndarray, List]</code> <p>description</p> required <code>block_input</code> <code>Union[List, Dict]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> <code>extra_kwargs</code> <code>Dict[str, Any]</code> <p>description, by default {}</p> <code>{}</code> Source code in <code>brahmap/core/noise_ops_block_diag.py</code> <pre><code>class BlockDiagInvNoiseCovLO(BlockDiagNoiseCovLO):\n    \"\"\"Linear operator for block-diagonal inverse noise covariance\n\n    Parameters\n    ----------\n    operator : _type_\n        _description_\n    block_size : Union[np.ndarray, List]\n        _description_\n    block_input : Union[List, Dict]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    extra_kwargs : Dict[str, Any], optional\n        _description_, by default {}\n    \"\"\"\n\n    def __init__(\n        self,\n        operator,\n        block_size: Union[np.ndarray, List],\n        block_input: Union[List, Dict],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        dtype: DTypeFloat = np.float64,\n        extra_kwargs: Dict[str, Any] = {},\n    ):\n        super(BlockDiagInvNoiseCovLO, self).__init__(\n            operator,\n            block_size,\n            block_input,\n            input_type,\n            dtype,\n            extra_kwargs,\n        )\n</code></pre>"},{"location":"api_reference/core/BlockDiagNoiseCovLO/","title":"<code>brahmap.core.BlockDiagNoiseCovLO</code>","text":"<p>               Bases: <code>BaseBlockDiagNoiseCovLinearOperator</code></p> <p>Linear operator for block-diagonal noise covariance</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>_type_</code> <p>description</p> required <code>block_size</code> <code>Union[ndarray, List]</code> <p>description</p> required <code>block_input</code> <code>Union[List, Dict]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> <code>extra_kwargs</code> <code>Dict[str, Any]</code> <p>description, by default {}</p> <code>{}</code> Source code in <code>brahmap/core/noise_ops_block_diag.py</code> <pre><code>class BlockDiagNoiseCovLO(BaseBlockDiagNoiseCovLinearOperator):\n    \"\"\"Linear operator for block-diagonal noise covariance\n\n    Parameters\n    ----------\n    operator : _type_\n        _description_\n    block_size : Union[np.ndarray, List]\n        _description_\n    block_input : Union[List, Dict]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    extra_kwargs : Dict[str, Any], optional\n        _description_, by default {}\n    \"\"\"\n\n    def __init__(\n        self,\n        operator,\n        block_size: Union[np.ndarray, List],\n        block_input: Union[List, Dict],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        dtype: DTypeFloat = np.float64,\n        extra_kwargs: Dict[str, Any] = {},\n    ):\n        if isinstance(block_input, list):\n            MPI_RAISE_EXCEPTION(\n                condition=(len(block_size) != len(block_input)),\n                exception=ValueError,\n                message=\"The number of blocks listed in `block_size` is different\"\n                \" from the number of blocks provided in `block_input`\",\n            )\n\n            block_list = self.__build_blocks_from_list(\n                operator=operator,\n                block_size=block_size,\n                block_input=block_input,\n                input_type=input_type,\n                dtype=dtype,\n                extra_kwargs=extra_kwargs,\n            )\n\n        elif isinstance(block_input, dict):\n            block_list = self.__build_blocks_from_dict(\n                operator=operator,\n                block_size=block_size,\n                block_input=block_input,\n                input_type=input_type,\n                dtype=dtype,\n                extra_kwargs=extra_kwargs,\n            )\n\n        else:\n            MPI_RAISE_EXCEPTION(\n                condition=True,\n                exception=ValueError,\n                message=\"`block_input` must be either a list of arrays or list\"\n                \" OR a dictionary that maps operator size to an array or a list\",\n            )\n\n        super(BlockDiagNoiseCovLO, self).__init__(\n            block_list=block_list,\n        )\n\n    def __build_blocks_from_list(\n        self,\n        operator,\n        block_input: List,\n        block_size: Union[np.ndarray, List],\n        input_type,\n        dtype,\n        extra_kwargs,\n    ):\n        block_list = []\n        for idx, input in enumerate(block_input):\n            block_op = operator(\n                size=block_size[idx],\n                input=input,\n                input_type=input_type,\n                dtype=dtype,\n                **extra_kwargs,\n            )\n            block_list.append(block_op)\n\n        return block_list\n\n    def __build_blocks_from_dict(\n        self,\n        operator,\n        block_input: Dict,\n        block_size: Union[np.ndarray, List],\n        input_type,\n        dtype,\n        extra_kwargs,\n    ):\n        op_dict = {}\n        for shape in block_input.keys():\n            op_dict[shape] = operator(\n                size=shape,\n                input=block_input[shape],\n                input_type=input_type,\n                dtype=dtype,\n                **extra_kwargs,\n            )\n\n        block_list = []\n        for shape in block_size:\n            if shape in op_dict.keys():\n                block_list.append(op_dict[shape])\n            else:\n                MPI_RAISE_EXCEPTION(\n                    condition=True,\n                    exception=ValueError,\n                    message=f\"Operator for shape {shape} is missing from the input dictionary\",\n                )\n\n        return block_list\n</code></pre>"},{"location":"api_reference/core/BlockDiagonalPreconditionerLO/","title":"<code>brahmap.core.BlockDiagonalPreconditionerLO</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>Standard preconditioner defined as:</p> \\[M_{BD}=( P^T diag(N^{-1}) P)^{-1}\\] <p>where \\(P\\) is the pointing matrix (see <code>PointingLO</code>). Such inverse operator  could be easily computed given the structure of the matrix \\(P\\).</p> <p>Parameters:</p> Name Type Description Default <code>processed_samples</code> <code>ProcessTimeSamples</code> <p>description</p> required <code>solver_type</code> <code>Union[None, SolverType]</code> <p>description, by default None</p> <code>None</code> Source code in <code>brahmap/core/linearoperators.py</code> <pre><code>class BlockDiagonalPreconditionerLO(LinearOperator):\n    r\"\"\"\n    Standard preconditioner defined as:\n\n    $$M_{BD}=( P^T diag(N^{-1}) P)^{-1}$$\n\n    where $P$ is the *pointing matrix* (see `PointingLO`).\n    Such inverse operator  could be easily computed given the structure of the\n    matrix $P$.\n\n    Parameters\n    ----------\n    processed_samples : ProcessTimeSamples\n        _description_\n    solver_type : Union[None, SolverType], optional\n        _description_, by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        processed_samples: ProcessTimeSamples,\n        solver_type: Union[None, SolverType] = None,\n    ):\n        if solver_type is None:\n            self.__solver_type = processed_samples.solver_type\n        else:\n            MPI_RAISE_EXCEPTION(\n                condition=(int(processed_samples.solver_type) &lt; int(solver_type)),\n                exception=ValueError,\n                message=\"`solver_type` must be lower than or equal to the\"\n                \"`solver_type` of `processed_samples` object\",\n            )\n            self.__solver_type = solver_type\n\n        self.new_npix = processed_samples.new_npix\n        self.size = processed_samples.new_npix * self.solver_type\n\n        if self.solver_type == 1:\n            self.weighted_counts = processed_samples.weighted_counts\n        else:\n            self.weighted_sin_sq = processed_samples.weighted_sin_sq\n            self.weighted_cos_sq = processed_samples.weighted_cos_sq\n            self.weighted_sincos = processed_samples.weighted_sincos\n            self.one_over_determinant = processed_samples.one_over_determinant\n            if self.solver_type == 3:\n                self.weighted_counts = processed_samples.weighted_counts\n                self.weighted_sin = processed_samples.weighted_sin\n                self.weighted_cos = processed_samples.weighted_cos\n\n        if self.solver_type == 1:\n            super(BlockDiagonalPreconditionerLO, self).__init__(\n                nargin=self.size,\n                nargout=self.size,\n                symmetric=True,\n                matvec=self._mult_I,\n                dtype=processed_samples.dtype_float,\n            )\n        elif self.solver_type == 2:\n            super(BlockDiagonalPreconditionerLO, self).__init__(\n                nargin=self.size,\n                nargout=self.size,\n                symmetric=True,\n                matvec=self._mult_QU,\n                dtype=processed_samples.dtype_float,\n            )\n        else:\n            super(BlockDiagonalPreconditionerLO, self).__init__(\n                nargin=self.size,\n                nargout=self.size,\n                symmetric=True,\n                matvec=self._mult_IQU,\n                dtype=processed_samples.dtype_float,\n            )\n\n    def _mult_I(self, vec: np.ndarray):\n        r\"\"\"\n        Action of :math:`y=( A  diag(N^{-1}) A^T)^{-1} x`,\n        where :math:`x` is   an :math:`n_{pix}` array.\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.size),\n            exception=ValueError,\n            message=f\"Dimenstions of `vec` is not compatible with the dimension of this `BlockDiagonalPreconditionerLO` instance.\\nShape of `BlockDiagonalPreconditionerLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = vec / self.weighted_counts\n\n        return prod\n\n    def _mult_QU(self, vec: np.ndarray):\n        r\"\"\"\n        Action of :math:`y=( A  diag(N^{-1}) A^T)^{-1} x`,\n        where :math:`x` is   an :math:`n_{pix}` array.\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.size),\n            exception=ValueError,\n            message=f\"Dimenstions of `vec` is not compatible with the dimension of this `BlockDiagonalPreconditionerLO` instance.\\nShape of `BlockDiagonalPreconditionerLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.size, dtype=self.dtype)\n\n        BlkDiagPrecondLO_tools.BDPLO_mult_QU(\n            new_npix=self.new_npix,\n            weighted_sin_sq=self.weighted_sin_sq,\n            weighted_cos_sq=self.weighted_cos_sq,\n            weighted_sincos=self.weighted_sincos,\n            one_over_determinant=self.one_over_determinant,\n            vec=vec,\n            prod=prod,\n        )\n\n        return prod\n\n    def _mult_IQU(self, vec: np.ndarray):\n        r\"\"\"\n        Action of :math:`y=( A  diag(N^{-1}) A^T)^{-1} x`,\n        where :math:`x` is   an :math:`n_{pix}` array.\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.size),\n            exception=ValueError,\n            message=f\"Dimenstions of `vec` is not compatible with the dimension of this `BlockDiagonalPreconditionerLO` instance.\\nShape of `BlockDiagonalPreconditionerLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.size, dtype=self.dtype)\n\n        BlkDiagPrecondLO_tools.BDPLO_mult_IQU(\n            new_npix=self.new_npix,\n            weighted_counts=self.weighted_counts,\n            weighted_sin_sq=self.weighted_sin_sq,\n            weighted_cos_sq=self.weighted_cos_sq,\n            weighted_sincos=self.weighted_sincos,\n            weighted_sin=self.weighted_sin,\n            weighted_cos=self.weighted_cos,\n            one_over_determinant=self.one_over_determinant,\n            vec=vec,\n            prod=prod,\n        )\n\n        return prod\n\n    @property\n    def solver_type(self):\n        return self.__solver_type\n</code></pre>"},{"location":"api_reference/core/GLSParameters/","title":"<code>brahmap.core.GLSParameters</code>","text":"<p>A class to encapsulate the parameters used for GLS map-making</p> <p>Attributes:</p> Name Type Description <code>solver_type</code> <code>SolverType</code> <p>description</p> <code>use_iterative_solver</code> <code>bool</code> <p>description</p> <code>isolver_threshold</code> <code>float</code> <p>description</p> <code>isolver_max_iterations</code> <code>int</code> <p>description</p> <code>callback_function</code> <code>Callable</code> <p>description</p> <code>return_processed_samples</code> <code>bool</code> <p>description</p> <code>return_hit_map</code> <code>bool</code> <p>description</p> Source code in <code>brahmap/core/GLS.py</code> <pre><code>@dataclass\nclass GLSParameters:\n    \"\"\"A class to encapsulate the parameters used for GLS map-making\n\n    Attributes\n    ----------\n    solver_type : SolverType\n        _description_\n    use_iterative_solver : bool\n        _description_\n    isolver_threshold : float\n        _description_\n    isolver_max_iterations : int\n        _description_\n    callback_function : Callable\n        _description_\n    return_processed_samples : bool\n        _description_\n    return_hit_map : bool\n        _description_\n    \"\"\"\n\n    solver_type: SolverType = SolverType.IQU\n    use_iterative_solver: bool = True\n    isolver_threshold: float = 1.0e-12\n    isolver_max_iterations: int = 100\n    callback_function: Callable = None\n    return_processed_samples: bool = False\n    return_hit_map: bool = False\n</code></pre>"},{"location":"api_reference/core/GLSResult/","title":"<code>brahmap.core.GLSResult</code>","text":"<p>A class to store the results of the GLS map-making</p> <p>Parameters:</p> Name Type Description Default <code>solver_type</code> <code>SolverType</code> <p>description</p> required <code>npix</code> <code>int</code> <p>description</p> required <code>new_npix</code> <code>int</code> <p>description</p> required <code>GLS_maps</code> <code>ndarray</code> <p>description</p> required <code>hit_map</code> <code>ndarray</code> <p>description</p> required <code>convergence_status</code> <code>bool</code> <p>description</p> required <code>num_iterations</code> <code>int</code> <p>description</p> required <code>GLSParameters</code> <code>GLSParameters</code> <p>description</p> required Source code in <code>brahmap/core/GLS.py</code> <pre><code>@dataclass\nclass GLSResult:\n    \"\"\"A class to store the results of the GLS map-making\n\n    Parameters\n    ----------\n    solver_type : SolverType\n        _description_\n    npix : int\n        _description_\n    new_npix : int\n        _description_\n    GLS_maps : np.ndarray\n        _description_\n    hit_map : np.ndarray\n        _description_\n    convergence_status : bool\n        _description_\n    num_iterations : int\n        _description_\n    GLSParameters : GLSParameters\n        _description_\n    \"\"\"\n\n    solver_type: SolverType\n    npix: int\n    new_npix: int\n    GLS_maps: np.ndarray\n    hit_map: np.ndarray\n    convergence_status: bool\n    num_iterations: int\n    GLSParameters: GLSParameters\n</code></pre>"},{"location":"api_reference/core/InvNoiseCovLO_Circulant/","title":"<code>brahmap.core.InvNoiseCovLO_Circulant</code>","text":"<p>               Bases: <code>InvNoiseCovLinearOperator</code></p> <p>Linear operator for the inverse of Circulant noise covariance</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>description</p> required <code>input</code> <code>Union[ndarray, List]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/core/noise_ops_circulant.py</code> <pre><code>class InvNoiseCovLO_Circulant(InvNoiseCovLinearOperator):\n    \"\"\"Linear operator for the inverse of Circulant noise covariance\n\n    Parameters\n    ----------\n    size : int\n        _description_\n    input : Union[np.ndarray, List]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        input: Union[np.ndarray, List],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        dtype: DTypeFloat = np.float64,\n    ):\n        input = np.asarray(a=input, dtype=dtype)\n\n        MPI_RAISE_EXCEPTION(\n            condition=(input.ndim != 1),\n            exception=ValueError,\n            message=\"The `input` array must be a 1-d vector\",\n        )\n        MPI_RAISE_EXCEPTION(\n            condition=(size != input.shape[0]),\n            exception=ValueError,\n            message=\"The input array size must be same as the size of the linear operator\",\n        )\n\n        if input_type == \"covariance\":\n            self.__input = 1.0 / np.fft.fft(input).real.astype(dtype=dtype, copy=False)\n        elif input_type == \"power_spectrum\":\n            self.__input = 1.0 / input\n\n        super(InvNoiseCovLO_Circulant, self).__init__(\n            nargin=size,\n            matvec=self._mult,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        factor = np.average(self.__input)\n        return factor * np.ones(self.size, dtype=self.dtype)\n\n    def get_inverse(self):\n        noise_cov = NoiseCovLO_Circulant(\n            size=self.size,\n            input=1.0 / self.__input,\n            input_type=\"power_spectrum\",\n            dtype=self.dtype,\n        )\n        return noise_cov\n\n    def _mult(self, vec: np.ndarray):\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.shape[0]),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimensions of this `InvNoiseCovLO_Circulant` instance.\\nShape of `InvNoiseCovLO_Circulant` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.fft.ifft(vec)\n        prod = prod * self.__input\n        prod = np.real(np.fft.fft(prod))\n\n        return prod\n</code></pre>"},{"location":"api_reference/core/InvNoiseCovLO_Diagonal/","title":"<code>brahmap.core.InvNoiseCovLO_Diagonal</code>","text":"<p>               Bases: <code>InvNoiseCovLinearOperator</code></p> <p>Linear operator for the inverse of diagonal noise covariance</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>description</p> required <code>input</code> <code>Union[ndarray, List, DTypeFloat]</code> <p>description, by default 1.0</p> <code>1.0</code> <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"covariance\"</p> <code>'covariance'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/core/noise_ops_diagonal.py</code> <pre><code>class InvNoiseCovLO_Diagonal(InvNoiseCovLinearOperator):\n    \"\"\"Linear operator for the inverse of diagonal noise covariance\n\n    Parameters\n    ----------\n    size : int\n        _description_\n    input : Union[np.ndarray, List, DTypeFloat], optional\n        _description_, by default 1.0\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"covariance\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        input: Union[np.ndarray, List, DTypeFloat] = 1.0,\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"covariance\",\n        dtype: DTypeFloat = np.float64,\n    ):\n        if isinstance(input, Number) and input_type == \"covariance\":\n            self.__inv_noise_cov = np.full(\n                shape=size, fill_value=1.0 / input, dtype=dtype\n            )\n        elif input_type == \"covariance\":\n            self.__inv_noise_cov = 1.0 / np.asarray(a=input, dtype=dtype)\n        elif input_type == \"power_spectrum\":\n            self.__inv_noise_cov = 1.0 / np.fft.ifft(input).real.astype(\n                dtype=dtype, copy=False\n            )\n\n        MPI_RAISE_EXCEPTION(\n            condition=(self.__inv_noise_cov.ndim != 1),\n            exception=ValueError,\n            message=\"The `input` array must be a 1-d vector\",\n        )\n        MPI_RAISE_EXCEPTION(\n            condition=(size != self.__inv_noise_cov.shape[0]),\n            exception=ValueError,\n            message=\"The input array size must be same as the size of the linear operator\",\n        )\n\n        super(InvNoiseCovLO_Diagonal, self).__init__(\n            nargin=size,\n            matvec=self._mult,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        return self.__inv_noise_cov\n\n    def get_inverse(self):\n        noise_cov = NoiseCovLO_Diagonal(\n            size=self.shape[0],\n            input=1.0 / self.__inv_noise_cov,\n            input_type=\"covariance\",\n            dtype=self.dtype,\n        )\n        return noise_cov\n\n    def _mult(self, vec: np.ndarray):\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.shape[0]),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimensions of this `InvNoiseCovLO_Diagonal` instance.\\nShape of `InvNoiseCovLO_Diagonal` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.shape[0], dtype=self.dtype)\n\n        linalg_tools.multiply_array(\n            nsamples=self.shape[0],\n            diag=self.__inv_noise_cov,\n            vec=vec,\n            prod=prod,\n        )\n\n        return prod\n</code></pre>"},{"location":"api_reference/core/InvNoiseCovLO_Toeplitz01/","title":"<code>brahmap.core.InvNoiseCovLO_Toeplitz01</code>","text":"<p>               Bases: <code>InvNoiseCovLinearOperator</code></p> <p>Linear operator for the inverse of Toeplitz noise covariance</p> <p>The input covariance array must be at least of the size n. The input power spectrum array must be of the size 2n-2 or 2n-1.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>description</p> required <code>input</code> <code>Union[ndarray, List]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>precond_op</code> <code>Union[LinearOperator, Literal[None, 'Strang', 'TChan', 'RChan', 'KK2']]</code> <p>description, by default None</p> <code>None</code> <code>precond_maxiter</code> <code>int</code> <p>description, by default 50</p> <code>50</code> <code>precond_atol</code> <code>float</code> <p>description, by default 1.0e-10</p> <code>1e-10</code> <code>precond_callback</code> <code>Callable</code> <p>description, by default None</p> <code>None</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/core/noise_ops_toeplitz.py</code> <pre><code>class InvNoiseCovLO_Toeplitz01(InvNoiseCovLinearOperator):\n    \"\"\"Linear operator for the inverse of Toeplitz noise covariance\n\n    The input covariance array must be at least of the size n. The input power\n    spectrum array must be of the size 2n-2 or 2n-1.\n\n    Parameters\n    ----------\n    size : int\n        _description_\n    input : Union[np.ndarray, List]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    precond_op : Union[ LinearOperator, Literal[None, \"Strang\", \"TChan\", \"RChan\", \"KK2\"] ], optional\n        _description_, by default None\n    precond_maxiter : int, optional\n        _description_, by default 50\n    precond_atol : float, optional\n        _description_, by default 1.0e-10\n    precond_callback : Callable, optional\n        _description_, by default None\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        input: Union[np.ndarray, List],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        precond_op: Union[\n            LinearOperator, Literal[None, \"Strang\", \"TChan\", \"RChan\", \"KK2\"]\n        ] = None,\n        precond_maxiter: int = 50,\n        precond_atol: float = 1.0e-10,\n        precond_callback: Callable = None,\n        dtype: DTypeFloat = np.float64,\n    ):\n        self.__toeplitz_op = NoiseCovLO_Toeplitz01(\n            size=size,\n            input=input,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n        self.precond_atol = precond_atol\n        self.precond_maxiter = precond_maxiter\n        self.precond_callback = precond_callback\n\n        self.__previous_num_iterations = 0\n\n        super(InvNoiseCovLO_Toeplitz01, self).__init__(\n            nargin=size,\n            matvec=self._mult,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n        if precond_op is None:\n            self.precond_op = None\n        elif isinstance(precond_op, LinearOperator) or isinstance(\n            precond_op, np.ndarray\n        ):\n            self.precond_op = precond_op\n        elif precond_op in [\"Strang\", \"TChan\", \"RChan\", \"KK2\"]:\n            if input_type == \"power_spectrum\":\n                cov = np.fft.ifft(input).real[:size]\n            else:\n                cov = input[:size]\n\n            if precond_op == \"Strang\":\n                temp_size = int(np.floor(cov.size / 2))\n                if cov.size % 2 == 0:\n                    new_cov = np.concatenate(\n                        [cov[:temp_size], cov[1 : temp_size + 1][::-1]]\n                    )\n                else:\n                    new_cov = np.concatenate(\n                        [cov[: temp_size + 1], cov[1 : temp_size + 1][::-1]]\n                    )\n            elif precond_op == \"TChan\":\n                new_cov = np.empty_like(cov)\n                new_cov[0] = cov[0]\n                n = cov.size\n                for idx in range(1, n):\n                    new_cov[idx] = ((n - idx) * cov[idx] + idx * cov[n - idx]) / n\n            elif precond_op == \"RChan\":\n                new_cov = np.roll(np.flip(cov), 1)\n                new_cov += cov\n                new_cov[0] = cov[0]\n            elif precond_op == \"KK2\":  # Circulant but not symmetric\n                new_cov = np.roll(np.flip(cov), 1)\n                new_cov[0] = 0\n                new_cov = cov - new_cov\n\n            self.precond_op = InvNoiseCovLO_Circulant(\n                size=size,\n                input=new_cov,\n                input_type=\"covariance\",\n                dtype=dtype,\n            )\n        else:\n            MPI_RAISE_EXCEPTION(\n                condition=True,\n                exception=ValueError,\n                message=\"Invalid preconditioner operator provided!\",\n            )\n\n    @property\n    def precond_op(self):\n        return self.__precond_op\n\n    @precond_op.setter\n    def precond_op(self, operator: LinearOperator):\n        if operator is not None:\n            MPI_RAISE_EXCEPTION(\n                condition=(self.shape != operator.shape),\n                exception=ValueError,\n                message=f\"The shape of the input operator {operator.shape} is not compatible with the shape of inverse Toeplitz operator {self.shape}\",\n            )\n        self.__precond_op = operator\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        try:\n            diag_arr = getattr(self, \"__diag\")\n        except AttributeError:\n            factor = 1.0\n            diag_arr = factor * np.ones(self.size, dtype=self.dtype)\n        return diag_arr\n\n    @diag.setter\n    def diag(self, diag: np.ndarray):\n        self.__diag = diag\n\n    @property\n    def previous_num_iterations(self) -&gt; int:\n        return self.__previous_num_iterations\n\n    def get_inverse(self):\n        return self.__toeplitz_op\n\n    def __callback(self, x, r, norm_residual):\n        self.__previous_num_iterations += 1\n        if self.precond_callback is not None:\n            self.precond_callback(x, r, norm_residual)\n\n    def _mult(self, vec: np.ndarray):\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.shape[0]),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimensions of this `InvNoiseCovLO_Toeplitz` instance.\\nShape of `InvNoiseCovLO_Toeplitz` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        self.__previous_num_iterations = 0\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod, _ = cg(\n            A=self.__toeplitz_op,\n            b=vec,\n            atol=self.precond_atol,\n            maxiter=self.precond_maxiter,\n            M=self.precond_op,\n            callback=self.__callback,\n            parallel=False,\n        )\n\n        return prod\n</code></pre>"},{"location":"api_reference/core/NoiseCovLO_Circulant/","title":"<code>brahmap.core.NoiseCovLO_Circulant</code>","text":"<p>               Bases: <code>NoiseCovLinearOperator</code></p> <p>Linear operator for Circulant noise covariance</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>description</p> required <code>input</code> <code>Union[ndarray, List]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/core/noise_ops_circulant.py</code> <pre><code>class NoiseCovLO_Circulant(NoiseCovLinearOperator):\n    \"\"\"Linear operator for Circulant noise covariance\n\n    Parameters\n    ----------\n    size : int\n        _description_\n    input : Union[np.ndarray, List]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        input: Union[np.ndarray, List],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        dtype: DTypeFloat = np.float64,\n    ):\n        input = np.asarray(a=input, dtype=dtype)\n\n        MPI_RAISE_EXCEPTION(\n            condition=(input.ndim != 1),\n            exception=ValueError,\n            message=\"The `input` array must be a 1-d vector\",\n        )\n        MPI_RAISE_EXCEPTION(\n            condition=(size != input.shape[0]),\n            exception=ValueError,\n            message=\"The input array size must be same as the size of the linear operator\",\n        )\n\n        if input_type == \"covariance\":\n            self.__input = np.fft.fft(input).real.astype(dtype=dtype, copy=False)\n        elif input_type == \"power_spectrum\":\n            self.__input = input\n\n        super(NoiseCovLO_Circulant, self).__init__(\n            nargin=size,\n            matvec=self._mult,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        factor = np.average(self.__input)\n        return factor * np.ones(self.size, dtype=self.dtype)\n\n    def get_inverse(self):\n        inv_noise_cov = InvNoiseCovLO_Circulant(\n            size=self.size,\n            input=self.__input,\n            input_type=\"power_spectrum\",\n            dtype=self.dtype,\n        )\n        return inv_noise_cov\n\n    def _mult(self, vec: np.ndarray):\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.shape[0]),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimensions of this `NoiseCovLO_Circulant` instance.\\nShape of `NoiseCovLO_Circulant` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.fft.ifft(vec)\n        prod = prod * self.__input\n        prod = np.real(np.fft.fft(prod))\n\n        return prod\n</code></pre>"},{"location":"api_reference/core/NoiseCovLO_Diagonal/","title":"<code>brahmap.core.NoiseCovLO_Diagonal</code>","text":"<p>               Bases: <code>NoiseCovLinearOperator</code></p> <p>Linear operator for diagonal noise covariance</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>description</p> required <code>input</code> <code>Union[ndarray, List, DTypeFloat]</code> <p>description, by default 1.0</p> <code>1.0</code> <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"covariance\"</p> <code>'covariance'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/core/noise_ops_diagonal.py</code> <pre><code>class NoiseCovLO_Diagonal(NoiseCovLinearOperator):\n    \"\"\"Linear operator for diagonal noise covariance\n\n    Parameters\n    ----------\n    size : int\n        _description_\n    input : Union[np.ndarray, List, DTypeFloat], optional\n        _description_, by default 1.0\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"covariance\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        input: Union[np.ndarray, List, DTypeFloat] = 1.0,\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"covariance\",\n        dtype: DTypeFloat = np.float64,\n    ):\n        if isinstance(input, Number) and input_type == \"covariance\":\n            self.__noise_covariance = np.full(shape=size, fill_value=input, dtype=dtype)\n        elif input_type == \"covariance\":\n            self.__noise_covariance = np.asarray(a=input, dtype=dtype)\n        elif input_type == \"power_spectrum\":\n            self.__noise_covariance = np.fft.ifft(input).real.astype(\n                dtype=dtype, copy=False\n            )\n\n        MPI_RAISE_EXCEPTION(\n            condition=(self.__noise_covariance.ndim != 1),\n            exception=ValueError,\n            message=\"The `input` array must be a 1-d vector\",\n        )\n        MPI_RAISE_EXCEPTION(\n            condition=(size != self.__noise_covariance.shape[0]),\n            exception=ValueError,\n            message=\"The input array size must be same as the size of the linear operator\",\n        )\n\n        super(NoiseCovLO_Diagonal, self).__init__(\n            nargin=size,\n            matvec=self._mult,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        return self.__noise_covariance\n\n    def get_inverse(self):\n        inv_noise_cov = InvNoiseCovLO_Diagonal(\n            size=self.shape[0],\n            input=self.__noise_covariance,\n            input_type=\"covariance\",\n            dtype=self.dtype,\n        )\n        return inv_noise_cov\n\n    def _mult(self, vec: np.ndarray):\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.shape[0]),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimensions of this `InvNoiseCovLO_Diagonal` instance.\\nShape of `InvNoiseCovLO_Diagonal` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.shape[0], dtype=self.dtype)\n\n        linalg_tools.multiply_array(\n            nsamples=self.shape[0],\n            diag=self.__noise_covariance,\n            vec=vec,\n            prod=prod,\n        )\n\n        return prod\n</code></pre>"},{"location":"api_reference/core/NoiseCovLO_Toeplitz01/","title":"<code>brahmap.core.NoiseCovLO_Toeplitz01</code>","text":"<p>               Bases: <code>NoiseCovLinearOperator</code></p> <p>Linear operator for Toeplitz noise covariance</p> <p>The input covariance array must be at least of the size n. The input power spectrum array must be of the size 2n-2 or 2n-1.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>description</p> required <code>input</code> <code>Union[ndarray, List]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/core/noise_ops_toeplitz.py</code> <pre><code>class NoiseCovLO_Toeplitz01(NoiseCovLinearOperator):\n    \"\"\"Linear operator for Toeplitz noise covariance\n\n    The input covariance array must be at least of the size n. The input power\n    spectrum array must be of the size 2n-2 or 2n-1.\n\n    Parameters\n    ----------\n    size : int\n        _description_\n    input : Union[np.ndarray, List]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        input: Union[np.ndarray, List],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        dtype: DTypeFloat = np.float64,\n    ):\n        input = np.asarray(a=input, dtype=dtype)\n\n        MPI_RAISE_EXCEPTION(\n            condition=(input.ndim != 1),\n            exception=ValueError,\n            message=\"The `input` array must be a 1-d vector\",\n        )\n\n        if input_type == \"covariance\":\n            MPI_RAISE_EXCEPTION(\n                condition=(size &gt; input.shape[0]),\n                exception=ValueError,\n                message=\"The input noise covariance array must be at least of the size of the linear operator\",\n            )\n            covariance = input[:size]\n        elif input_type == \"power_spectrum\":\n            MPI_RAISE_EXCEPTION(\n                condition=(\n                    (2 * size - 1 != input.shape[0])\n                    and (2 * size - 2 != input.shape[0])\n                ),\n                exception=ValueError,\n                message=\"The input power spectrum array must be of the size 2n-2 or 2n-1, where n is the size of the linear operator\",\n            )\n            covariance = np.fft.ifft(input)[:size]\n            covariance = covariance.real.astype(dtype=dtype)\n\n        self.__diag_factor = covariance[0]\n        self.__input = np.concatenate([covariance, np.roll(covariance[::-1], 1)])\n        self.__input = np.fft.fft(self.__input)\n\n        del covariance\n\n        super(NoiseCovLO_Toeplitz01, self).__init__(\n            nargin=size,\n            matvec=self._mult,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n    @property\n    def diag(self) -&gt; np.ndarray:\n        return self.__diag_factor * np.ones(self.size, dtype=self.dtype)\n\n    def get_inverse(self):\n        covariance = np.fft.ifft(self.__input)[: self.size]\n        covariance = covariance.real.astype(dtype=self.dtype)\n        inv_noise_cov = InvNoiseCovLO_Toeplitz01(\n            size=self.size,\n            input=covariance,\n            input_type=\"covariance\",\n            dtype=self.dtype,\n        )\n        return inv_noise_cov\n\n    def _mult(self, vec: np.ndarray):\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.shape[0]),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimensions of this `NoiseCovLO_Toeplitz` instance.\\nShape of `NoiseCovLO_Toeplitz` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.pad(vec, pad_width=((0, self.size)), mode=\"constant\")\n\n        prod = np.fft.ifft(prod)\n        prod = prod * self.__input\n        prod = np.fft.fft(prod)[: self.size]\n\n        return prod.real.astype(dtype=self.dtype, copy=False)\n</code></pre>"},{"location":"api_reference/core/PointingLO/","title":"<code>brahmap.core.PointingLO</code>","text":"<p>               Bases: <code>LinearOperator</code></p> <p>Derived class from the one from the  :class:<code>LinearOperator</code> in :mod:<code>linop</code>. It constitutes an interface for dealing with the projection operator (pointing matrix).</p> <p>Parameters:</p> Name Type Description Default <code>processed_samples</code> <code>ProcessTimeSamples</code> <p>description</p> required <code>solver_type</code> <code>Union[None, SolverType]</code> <p>description, by default None</p> <code>None</code> Source code in <code>brahmap/core/linearoperators.py</code> <pre><code>class PointingLO(LinearOperator):\n    \"\"\"Derived class from the one from the  :class:`LinearOperator` in :mod:`linop`.\n    It constitutes an interface for dealing with the projection operator\n    (pointing matrix).\n\n    Parameters\n    ----------\n    processed_samples : ProcessTimeSamples\n        _description_\n    solver_type : Union[None, SolverType], optional\n        _description_, by default None\n    \"\"\"\n\n    def __init__(\n        self,\n        processed_samples: ProcessTimeSamples,\n        solver_type: Union[None, SolverType] = None,\n    ):\n        if solver_type is None:\n            self.__solver_type = processed_samples.solver_type\n        else:\n            MPI_RAISE_EXCEPTION(\n                condition=(int(processed_samples.solver_type) &lt; int(solver_type)),\n                exception=ValueError,\n                message=\"`solver_type` must be lower than or equal to the\"\n                \"`solver_type` of `processed_samples` object\",\n            )\n            self.__solver_type = solver_type\n\n        self.new_npix = processed_samples.new_npix\n        self.ncols = processed_samples.new_npix * self.solver_type\n        self.nrows = processed_samples.nsamples\n\n        self.pointings = processed_samples.pointings\n        self.pointings_flag = processed_samples.pointings_flag\n\n        if self.solver_type &gt; 1:\n            self.sin2phi = processed_samples.sin2phi\n            self.cos2phi = processed_samples.cos2phi\n\n        if self.solver_type == 1:\n            super(PointingLO, self).__init__(\n                nargin=self.ncols,\n                nargout=self.nrows,\n                symmetric=False,\n                matvec=self._mult_I,\n                rmatvec=self._rmult_I,\n                dtype=processed_samples.dtype_float,\n            )\n        elif self.solver_type == 2:\n            super(PointingLO, self).__init__(\n                nargin=self.ncols,\n                nargout=self.nrows,\n                symmetric=False,\n                matvec=self._mult_QU,\n                rmatvec=self._rmult_QU,\n                dtype=processed_samples.dtype_float,\n            )\n        else:\n            super(PointingLO, self).__init__(\n                nargin=self.ncols,\n                nargout=self.nrows,\n                matvec=self._mult_IQU,\n                symmetric=False,\n                rmatvec=self._rmult_IQU,\n                dtype=processed_samples.dtype_float,\n            )\n\n    def _mult_I(self, vec: np.ndarray):\n        r\"\"\"\n        Performs the product of a sparse matrix :math:`Av`,\\\n         with :math:`v` a  :mod:`numpy`  array (:math:`dim(v)=n_{pix}`)  .\n\n        It extracts the components of :math:`v` corresponding  to the non-null \\\n        elements of the operator.\n\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.ncols),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimension of this `PointingLO` instance.\\nShape of `PointingLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.nrows, dtype=self.dtype)\n\n        PointingLO_tools.PLO_mult_I(\n            nsamples=self.nrows,\n            pointings=self.pointings,\n            pointings_flag=self.pointings_flag,\n            vec=vec,\n            prod=prod,\n        )\n\n        return prod\n\n    def _rmult_I(self, vec: np.ndarray):\n        r\"\"\"\n        Performs the product for the transpose operator :math:`A^T`.\n\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.nrows),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimension of this `PointingLO` instance.\\nShape of `PointingLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.ncols, dtype=self.dtype)\n\n        PointingLO_tools.PLO_rmult_I(\n            new_npix=self.new_npix,\n            nsamples=self.nrows,\n            pointings=self.pointings,\n            pointings_flag=self.pointings_flag,\n            vec=vec,\n            prod=prod,\n            comm=MPI_UTILS.comm,\n        )\n\n        return prod\n\n    def _mult_QU(self, vec: np.ndarray):\n        r\"\"\"Performs :math:`A * v` with :math:`v` being a *polarization* vector.\n        The output array will encode a linear combination of the two Stokes\n        parameters,  (whose components are stored contiguously).\n\n        .. math::\n            d_t=  Q_p \\cos(2\\phi_t)+ U_p \\sin(2\\phi_t).\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.ncols),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimension of this `PointingLO` instance.\\nShape of `PointingLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.nrows, dtype=self.dtype)\n\n        PointingLO_tools.PLO_mult_QU(\n            nsamples=self.nrows,\n            pointings=self.pointings,\n            pointings_flag=self.pointings_flag,\n            sin2phi=self.sin2phi,\n            cos2phi=self.cos2phi,\n            vec=vec,\n            prod=prod,\n        )\n\n        return prod\n\n    def _rmult_QU(self, vec: np.ndarray):\n        r\"\"\"\n        Performs :math:`A^T * v`. The output vector will be a QU-map-like array.\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.nrows),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimension of this `PointingLO` instance.\\nShape of `PointingLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.ncols, dtype=self.dtype)\n\n        PointingLO_tools.PLO_rmult_QU(\n            new_npix=self.new_npix,\n            nsamples=self.nrows,\n            pointings=self.pointings,\n            pointings_flag=self.pointings_flag,\n            sin2phi=self.sin2phi,\n            cos2phi=self.cos2phi,\n            vec=vec,\n            prod=prod,\n            comm=MPI_UTILS.comm,\n        )\n\n        return prod\n\n    def _mult_IQU(self, vec: np.ndarray):\n        r\"\"\"Performs the product of a sparse matrix :math:`Av`,\n        with ``v`` a  :mod:`numpy` array containing the\n        three Stokes parameters [IQU] .\n\n        .. note::\n            Compared to the operation ``mult`` this routine returns a\n            :math:`n_t`-size vector defined as:\n\n            .. math::\n                d_t= I_p + Q_p \\cos(2\\phi_t)+ U_p \\sin(2\\phi_t).\n\n            with :math:`p` is the pixel observed at time :math:`t` with polarization angle\n            :math:`\\phi_t`.\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.ncols),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimension of this `PointingLO` instance.\\nShape of `PointingLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.nrows, dtype=self.dtype)\n\n        PointingLO_tools.PLO_mult_IQU(\n            nsamples=self.nrows,\n            pointings=self.pointings,\n            pointings_flag=self.pointings_flag,\n            sin2phi=self.sin2phi,\n            cos2phi=self.cos2phi,\n            vec=vec,\n            prod=prod,\n        )\n\n        return prod\n\n    def _rmult_IQU(self, vec: np.ndarray):\n        r\"\"\"\n        Performs the product for the transpose operator :math:`A^T` to get a IQU map-like vector.\n        Since this vector resembles the pixel of 3 maps it has 3 times the size ``Npix``.\n        IQU values referring to the same pixel are  contiguously stored in the memory.\n\n        \"\"\"\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(vec) != self.nrows),\n            exception=ValueError,\n            message=f\"Dimensions of `vec` is not compatible with the dimension of this `PointingLO` instance.\\nShape of `PointingLO` instance: {self.shape}\\nShape of `vec`: {vec.shape}\",\n        )\n\n        if vec.dtype != self.dtype:\n            if MPI_UTILS.rank == 0:\n                warnings.warn(\n                    f\"dtype of `vec` will be changed to {self.dtype}\",\n                    TypeChangeWarning,\n                )\n            vec = vec.astype(dtype=self.dtype, copy=False)\n\n        prod = np.zeros(self.ncols, dtype=self.dtype)\n\n        PointingLO_tools.PLO_rmult_IQU(\n            new_npix=self.new_npix,\n            nsamples=self.nrows,\n            pointings=self.pointings,\n            pointings_flag=self.pointings_flag,\n            sin2phi=self.sin2phi,\n            cos2phi=self.cos2phi,\n            vec=vec,\n            prod=prod,\n            comm=MPI_UTILS.comm,\n        )\n\n        return prod\n\n    @property\n    def solver_type(self):\n        return self.__solver_type\n</code></pre>"},{"location":"api_reference/core/ProcessTimeSamples/","title":"<code>brahmap.core.ProcessTimeSamples</code>","text":"<p>               Bases: <code>object</code></p> <p>A class to store the pre-processed and pre-computed arrays that can be used later.</p> <p>Parameters:</p> Name Type Description Default <code>npix</code> <code>int</code> <p>Number of pixels on which the map-making has to be done. Equal to <code>healpy.nside2npix(nside)</code> for a healpix map of given <code>nside</code></p> required <code>pointings</code> <code>ndarray</code> <p>A 1-d array of pointing indices</p> required <code>pointings_flag</code> <code>ndarray</code> <p>A 1-d array of pointing flags. <code>True</code> means good pointing, <code>False</code> means bad pointing.</p> <code>None</code> <code>solver_type</code> <code>SolverType</code> <p>Map-making level: I or QU or IQU</p> <code>IQU</code> <code>pol_angles</code> <code>ndarray | None</code> <p>A 1-d array containing the orientation angles of the detectors</p> <code>None</code> <code>noise_weights</code> <code>ndarray | None</code> <p>A 1-d array of noise weights, or the diagonal elements of the inverse of noise covariance matrix</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The threshold to be used to flag pixels in the sky</p> <code>1e-05</code> <code>dtype_float</code> <code>boh</code> <p><code>dtype</code> of the floating point arrays</p> <code>None</code> <code>update_pointings_inplace</code> <code>bool</code> <p>The class does some operations on the pointings array. Do you want to make these operations happen in-place? If yes, you will save a lot of memory. Not recommended if you are willing to use pointing arrays somewhere after doing map-making.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>npix</code> <code>int</code> <p>Number of pixels on which the map-making has to be done</p> <code>pointings</code> <code>ndarray</code> <p>A 1-d array of pointing indices</p> <code>pointings_flag</code> <code>ndarray</code> <p>A 1-d array of pointing flags</p> <code>nsamples</code> <code>int</code> <p>Number of samples on present MPI rank</p> <code>nsamples_global</code> <code>int</code> <p>Global number of samples</p> <code>solver_type</code> <code>SolverType</code> <p>Level of map-making: I, QU, or IQU</p> <code>pol_angles</code> <code>ndarray</code> <p>A 1-d array containing the orientation angles of detectors</p> <code>threshold</code> <code>float</code> <p>Threshold to be used to flag the pixels in the sky</p> <code>dtype_float</code> <code>boh</code> <p><code>dtype</code> of the floating point arrays</p> <code>observed_pixels</code> <code>ndarray</code> <p>Pixel indices that are considered for map-making</p> <code>pixel_flag</code> <code>ndarray</code> <p>A 1-d array of size <code>npix</code>. <code>True</code> indicates that the corresponding pixel index will be dropped in map-making</p> <code>bad_pixels</code> <code>ndarray</code> <p>A 1-d array that contains all the pixel indices that will be excluded in map-making</p> <code>weighted_counts</code> <code>ndarray</code> <p>Weighted counts</p> <code>sin2phi</code> <code>ndarray</code> <p>A 1-d array of \\(sin(2\\phi)\\)</p> <code>cos2phi</code> <code>ndarray</code> <p>A 1-d array of \\(cos(2\\phi)\\)</p> <code>weighted_sin</code> <code>ndarray</code> <p>Weighted <code>sin</code></p> <code>weighted_cos</code> <code>ndarray</code> <p>Weighted <code>cos</code></p> <code>weighted_sin_sq</code> <code>ndarray</code> <p>Weighted <code>sin^2</code></p> <code>weighted_cos_sq</code> <code>ndarray</code> <p>Weighted <code>cos^2</code></p> <code>weighted_sincos</code> <code>ndarray</code> <p>Weighted <code>sin.cos</code></p> <code>one_over_determinant</code> <code>ndarray</code> <p>Inverse of determinant for each valid pixels</p> <code>new_npix</code> <code>int</code> <p>The number of pixels actually being used in map-making. Equal to <code>len(observed_pixels)</code></p> Source code in <code>brahmap/core/process_time_samples.py</code> <pre><code>class ProcessTimeSamples(object):\n    \"\"\"\n    A class to store the pre-processed and pre-computed arrays that can be\n    used later.\n\n    Parameters\n    ----------\n    npix : int\n        Number of pixels on which the map-making has to be done. Equal to\n        `healpy.nside2npix(nside)` for a healpix map of given `nside`\n    pointings : np.ndarray\n        A 1-d array of pointing indices\n    pointings_flag : np.ndarray\n        A 1-d array of pointing flags. `True` means good pointing, `False`\n        means bad pointing.\n    solver_type : SolverType\n        Map-making level: I or QU or IQU\n    pol_angles : np.ndarray | None\n        A 1-d array containing the orientation angles of the detectors\n    noise_weights : np.ndarray | None\n        A 1-d array of noise weights, or the diagonal elements of the inverse\n        of noise covariance matrix\n    threshold : float\n        The threshold to be used to flag pixels in the sky\n    dtype_float : boh\n        `dtype` of the floating point arrays\n    update_pointings_inplace : bool\n        The class does some operations on the pointings array. Do you want to\n        make these operations happen in-place? If yes, you will save a lot of\n        memory. Not recommended if you are willing to use pointing arrays\n        somewhere after doing map-making.\n\n    Attributes\n    ----------\n    npix : int\n        Number of pixels on which the map-making has to be done\n    pointings : np.ndarray\n        A 1-d array of pointing indices\n    pointings_flag : np.ndarray\n        A 1-d array of pointing flags\n    nsamples : int\n        Number of samples on present MPI rank\n    nsamples_global : int\n        Global number of samples\n    solver_type : SolverType\n        Level of map-making: I, QU, or IQU\n    pol_angles : np.ndarray\n        A 1-d array containing the orientation angles of detectors\n    threshold : float\n        Threshold to be used to flag the pixels in the sky\n    dtype_float : boh\n        `dtype` of the floating point arrays\n    observed_pixels : np.ndarray\n        Pixel indices that are considered for map-making\n    pixel_flag : np.ndarray\n        A 1-d array of size `npix`. `True` indicates that the corresponding\n        pixel index will be dropped in map-making\n    bad_pixels : np.ndarray\n        A 1-d array that contains all the pixel indices that will be excluded\n        in map-making\n    weighted_counts : np.ndarray\n        Weighted counts\n    sin2phi : np.ndarray\n        A 1-d array of $sin(2\\\\phi)$\n    cos2phi : np.ndarray\n        A 1-d array of $cos(2\\\\phi)$\n    weighted_sin : np.ndarray\n        Weighted `sin`\n    weighted_cos : np.ndarray\n        Weighted `cos`\n    weighted_sin_sq : np.ndarray\n        Weighted `sin^2`\n    weighted_cos_sq : np.ndarray\n        Weighted `cos^2`\n    weighted_sincos : np.ndarray\n        Weighted `sin.cos`\n    one_over_determinant : np.ndarray\n        Inverse of determinant for each valid pixels\n    new_npix : int\n        The number of pixels actually being used in map-making. Equal to\n        `len(observed_pixels)`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        npix: int,\n        pointings: np.ndarray,\n        pointings_flag: Optional[np.ndarray] = None,\n        solver_type: SolverType = SolverType.IQU,\n        pol_angles: Optional[np.ndarray] = None,\n        noise_weights: Optional[np.ndarray] = None,\n        threshold: float = 1.0e-5,\n        dtype_float: Optional[DTypeFloat] = None,\n        update_pointings_inplace: bool = False,\n    ):\n        self.__npix = npix\n        self.__nsamples = len(pointings)\n\n        self.__nsamples_global = MPI_UTILS.comm.allreduce(self.nsamples, MPI.SUM)\n\n        if update_pointings_inplace:\n            self.pointings = pointings\n            self.pointings_flag = pointings_flag\n        else:\n            self.pointings = pointings.copy()\n            if pointings_flag is not None:\n                self.pointings_flag = pointings_flag.copy()\n\n        if pointings_flag is None:\n            self.pointings_flag = np.ones(self.nsamples, dtype=bool)\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(self.pointings_flag) != self.nsamples),\n            exception=AssertionError,\n            message=\"Size of `pointings_flag` must be equal to the size of \"\n            \"`pointings` array:\\n\"\n            f\"len(pointings_flag) = {len(self.pointings_flag)}\\n\"\n            f\"len(pointings) = {self.nsamples}\",\n        )\n\n        self.__solver_type = solver_type\n        self.__threshold = threshold\n\n        MPI_RAISE_EXCEPTION(\n            condition=(self.solver_type not in [1, 2, 3]),\n            exception=ValueError,\n            message=\"Invalid `solver_type`!!!\\n`solver_type` must be either \"\n            \"SolverType.I, SolverType.QU or SolverType.IQU \"\n            \"(equivalently 1, 2 or 3).\",\n        )\n\n        # setting the dtype for the `float` arrays: if one or both of\n        # `noise_weights` and `pol_angles` are supplied, the `dtype_float`\n        # will be inferred from them. Otherwise, the it will be set to\n        # `np.float64`\n        if dtype_float is not None:\n            self.__dtype_float = dtype_float\n        elif noise_weights is not None and pol_angles is not None:\n            # if both `noise_weights` and `pol_angles` are given,\n            # `dtype_float` will be assigned the higher `dtype`\n            self.__dtype_float = np.promote_types(\n                noise_weights.dtype,\n                pol_angles.dtype,\n            )\n        elif noise_weights is not None:\n            self.__dtype_float = noise_weights.dtype\n        elif pol_angles is not None:\n            self.__dtype_float = pol_angles.dtype\n        else:\n            self.__dtype_float = np.float64\n\n        if noise_weights is None:\n            noise_weights = np.ones(self.nsamples, dtype=self.dtype_float)\n\n        MPI_RAISE_EXCEPTION(\n            condition=(len(noise_weights) != self.nsamples),\n            exception=AssertionError,\n            message=\"Size of `noise_weights` must be equal to the size of \"\n            \"`pointings` array:\\n\"\n            f\"len(noise_weigths) = {len(noise_weights)}\\n\"\n            f\"len(pointings) = {self.nsamples}\",\n        )\n\n        try:\n            noise_weights = noise_weights.astype(\n                dtype=self.dtype_float, casting=\"safe\", copy=False\n            )\n        except TypeError:\n            raise TypeError(\n                \"The `noise_weights` array has higher dtype than \"\n                f\"`self.dtype_float={self.dtype_float}`. Please call \"\n                f\"`ProcessTimeSamples` again with `dtype_float={noise_weights.dtype}`\"\n            )\n\n        if self.solver_type != 1:\n            MPI_RAISE_EXCEPTION(\n                condition=(len(pol_angles) != self.nsamples),\n                exception=AssertionError,\n                message=\"Size of `pol_angles` must be equal to the size of \"\n                \"`pointings` array:\\n\"\n                f\"len(pol_angles) = {len(pol_angles)}\\n\"\n                f\"len(pointings) = {self.nsamples}\",\n            )\n\n            try:\n                pol_angles = pol_angles.astype(\n                    dtype=self.dtype_float, casting=\"safe\", copy=False\n                )\n            except TypeError:\n                raise TypeError(\n                    \"The `pol_angles` array has higher dtype than \"\n                    f\"`self.dtype_float={self.dtype_float}`. Please call \"\n                    f\"`ProcessTimeSamples` again with `dtype_float={pol_angles.dtype}`\"\n                )\n\n        self._compute_weights(\n            pol_angles,\n            noise_weights,\n        )\n\n        MPI_RAISE_EXCEPTION(\n            condition=(self.new_npix == 0),\n            exception=ValueError,\n            message=\"All pixels were found to be pathological. The map-making \"\n            \"cannot be done. Please ensure that the inputs are consistent!\",\n        )\n\n        self._repixelization()\n        self._flag_bad_pixel_samples()\n\n        if MPI_UTILS.rank == 0:\n            bc = bash_colors()\n            print(\n                f\"\\n{bc.header('--' * 13)} {bc.header(bc.bold('ProcessTimeSamples Summary'))} {bc.header('--' * 13)}\"\n            )\n\n            print(\n                bc.blue(\n                    bc.bold(\n                        f\"Processed {self.nsamples_global} time samples for npix={self.npix}\"\n                    )\n                )\n            )\n            print(\n                bc.blue(\n                    bc.bold(\n                        f\"Found {self.npix - self.new_npix} pathological pixels on the map\"\n                    )\n                )\n            )\n            print(\n                bc.blue(\n                    bc.bold(\n                        f\"Map-maker will take into account only {self.new_npix} pixels\"\n                    )\n                )\n            )\n            print(bc.header(f\"{'--' * 40}\"))\n\n    @property\n    def npix(self):\n        return self.__npix\n\n    @property\n    def nsamples(self):\n        return self.__nsamples\n\n    @property\n    def nsamples_global(self):\n        return self.__nsamples_global\n\n    @property\n    def solver_type(self):\n        return self.__solver_type\n\n    @property\n    def threshold(self):\n        return self.__threshold\n\n    @property\n    def dtype_float(self):\n        return self.__dtype_float\n\n    @property\n    def old2new_pixel(self):\n        old2new_pixel = np.zeros(self.npix, dtype=self.pointings.dtype)\n        for idx, flag in enumerate(self.pixel_flag):\n            if flag:\n                old2new_pixel[idx] = self.__old2new_pixel[idx]\n            else:\n                old2new_pixel[idx] = -1\n        return old2new_pixel\n\n    @property\n    def bad_pixels(self):\n        return np.nonzero(~self.pixel_flag)[0]\n\n    def get_hit_counts(self):\n        \"\"\"Returns hit counts of the pixel indices\"\"\"\n        hit_counts = np.ma.masked_array(\n            data=np.zeros(self.npix),\n            mask=np.logical_not(self.pixel_flag),\n            fill_value=-1.6375e30,\n        )\n\n        hit_counts[~hit_counts.mask] = self.hit_counts\n        return hit_counts\n\n    def _compute_weights(self, pol_angles: np.ndarray, noise_weights: np.ndarray):\n        self.hit_counts = np.zeros(self.npix, dtype=self.pointings.dtype)\n        self.weighted_counts = np.zeros(self.npix, dtype=self.dtype_float)\n        self.observed_pixels = np.zeros(self.npix, dtype=self.pointings.dtype)\n        self.__old2new_pixel = np.zeros(self.npix, dtype=self.pointings.dtype)\n        self.pixel_flag = np.zeros(self.npix, dtype=bool)\n\n        if self.solver_type == SolverType.I:\n            self.new_npix = compute_weights.compute_weights_pol_I(\n                npix=self.npix,\n                nsamples=self.nsamples,\n                pointings=self.pointings,\n                pointings_flag=self.pointings_flag,\n                noise_weights=noise_weights,\n                hit_counts=self.hit_counts,\n                weighted_counts=self.weighted_counts,\n                observed_pixels=self.observed_pixels,\n                __old2new_pixel=self.__old2new_pixel,\n                pixel_flag=self.pixel_flag,\n                comm=MPI_UTILS.comm,\n            )\n\n        else:\n            self.sin2phi = np.zeros(self.nsamples, dtype=self.dtype_float)\n            self.cos2phi = np.zeros(self.nsamples, dtype=self.dtype_float)\n\n            self.weighted_sin_sq = np.zeros(self.npix, dtype=self.dtype_float)\n            self.weighted_cos_sq = np.zeros(self.npix, dtype=self.dtype_float)\n            self.weighted_sincos = np.zeros(self.npix, dtype=self.dtype_float)\n\n            self.one_over_determinant = np.zeros(self.npix, dtype=self.dtype_float)\n\n            if self.solver_type == SolverType.QU:\n                compute_weights.compute_weights_pol_QU(\n                    npix=self.npix,\n                    nsamples=self.nsamples,\n                    pointings=self.pointings,\n                    pointings_flag=self.pointings_flag,\n                    noise_weights=noise_weights,\n                    pol_angles=pol_angles,\n                    hit_counts=self.hit_counts,\n                    weighted_counts=self.weighted_counts,\n                    sin2phi=self.sin2phi,\n                    cos2phi=self.cos2phi,\n                    weighted_sin_sq=self.weighted_sin_sq,\n                    weighted_cos_sq=self.weighted_cos_sq,\n                    weighted_sincos=self.weighted_sincos,\n                    one_over_determinant=self.one_over_determinant,\n                    comm=MPI_UTILS.comm,\n                )\n\n            elif self.solver_type == SolverType.IQU:\n                self.weighted_sin = np.zeros(self.npix, dtype=self.dtype_float)\n                self.weighted_cos = np.zeros(self.npix, dtype=self.dtype_float)\n\n                compute_weights.compute_weights_pol_IQU(\n                    npix=self.npix,\n                    nsamples=self.nsamples,\n                    pointings=self.pointings,\n                    pointings_flag=self.pointings_flag,\n                    noise_weights=noise_weights,\n                    pol_angles=pol_angles,\n                    hit_counts=self.hit_counts,\n                    weighted_counts=self.weighted_counts,\n                    sin2phi=self.sin2phi,\n                    cos2phi=self.cos2phi,\n                    weighted_sin_sq=self.weighted_sin_sq,\n                    weighted_cos_sq=self.weighted_cos_sq,\n                    weighted_sincos=self.weighted_sincos,\n                    weighted_sin=self.weighted_sin,\n                    weighted_cos=self.weighted_cos,\n                    one_over_determinant=self.one_over_determinant,\n                    comm=MPI_UTILS.comm,\n                )\n\n            self.new_npix = compute_weights.get_pixel_mask_pol(\n                solver_type=self.solver_type,\n                npix=self.npix,\n                threshold=self.threshold,\n                hit_counts=self.hit_counts,\n                one_over_determinant=self.one_over_determinant,\n                observed_pixels=self.observed_pixels,\n                __old2new_pixel=self.__old2new_pixel,\n                pixel_flag=self.pixel_flag,\n            )\n\n        self.observed_pixels.resize(self.new_npix, refcheck=False)\n\n    def _repixelization(self):\n        if self.solver_type == SolverType.I:\n            repixelize.repixelize_pol_I(\n                new_npix=self.new_npix,\n                observed_pixels=self.observed_pixels,\n                hit_counts=self.hit_counts,\n                weighted_counts=self.weighted_counts,\n            )\n\n            self.hit_counts.resize(self.new_npix, refcheck=False)\n            self.weighted_counts.resize(self.new_npix, refcheck=False)\n\n        elif self.solver_type == SolverType.QU:\n            repixelize.repixelize_pol_QU(\n                new_npix=self.new_npix,\n                observed_pixels=self.observed_pixels,\n                hit_counts=self.hit_counts,\n                weighted_counts=self.weighted_counts,\n                weighted_sin_sq=self.weighted_sin_sq,\n                weighted_cos_sq=self.weighted_cos_sq,\n                weighted_sincos=self.weighted_sincos,\n                one_over_determinant=self.one_over_determinant,\n            )\n\n            self.hit_counts.resize(self.new_npix, refcheck=False)\n            self.weighted_counts.resize(self.new_npix, refcheck=False)\n            self.weighted_sin_sq.resize(self.new_npix, refcheck=False)\n            self.weighted_cos_sq.resize(self.new_npix, refcheck=False)\n            self.weighted_sincos.resize(self.new_npix, refcheck=False)\n            self.one_over_determinant.resize(self.new_npix, refcheck=False)\n\n        elif self.solver_type == SolverType.IQU:\n            repixelize.repixelize_pol_IQU(\n                new_npix=self.new_npix,\n                observed_pixels=self.observed_pixels,\n                hit_counts=self.hit_counts,\n                weighted_counts=self.weighted_counts,\n                weighted_sin_sq=self.weighted_sin_sq,\n                weighted_cos_sq=self.weighted_cos_sq,\n                weighted_sincos=self.weighted_sincos,\n                weighted_sin=self.weighted_sin,\n                weighted_cos=self.weighted_cos,\n                one_over_determinant=self.one_over_determinant,\n            )\n\n            self.hit_counts.resize(self.new_npix, refcheck=False)\n            self.weighted_counts.resize(self.new_npix, refcheck=False)\n            self.weighted_sin_sq.resize(self.new_npix, refcheck=False)\n            self.weighted_cos_sq.resize(self.new_npix, refcheck=False)\n            self.weighted_sincos.resize(self.new_npix, refcheck=False)\n            self.weighted_sin.resize(self.new_npix, refcheck=False)\n            self.weighted_cos.resize(self.new_npix, refcheck=False)\n            self.one_over_determinant.resize(self.new_npix, refcheck=False)\n\n    def _flag_bad_pixel_samples(self):\n        repixelize.flag_bad_pixel_samples(\n            nsamples=self.nsamples,\n            pixel_flag=self.pixel_flag,\n            old2new_pixel=self.__old2new_pixel,\n            pointings=self.pointings,\n            pointings_flag=self.pointings_flag,\n        )\n</code></pre>"},{"location":"api_reference/core/ProcessTimeSamples/#brahmap.core.ProcessTimeSamples.get_hit_counts","title":"<code>get_hit_counts()</code>","text":"<p>Returns hit counts of the pixel indices</p> Source code in <code>brahmap/core/process_time_samples.py</code> <pre><code>def get_hit_counts(self):\n    \"\"\"Returns hit counts of the pixel indices\"\"\"\n    hit_counts = np.ma.masked_array(\n        data=np.zeros(self.npix),\n        mask=np.logical_not(self.pixel_flag),\n        fill_value=-1.6375e30,\n    )\n\n    hit_counts[~hit_counts.mask] = self.hit_counts\n    return hit_counts\n</code></pre>"},{"location":"api_reference/core/SolverType/","title":"<code>brahmap.core.SolverType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Map-making level: I, QU, or IQU</p> Source code in <code>brahmap/core/process_time_samples.py</code> <pre><code>class SolverType(IntEnum):\n    \"\"\"Map-making level: I, QU, or IQU\"\"\"\n\n    I = 1  # noqa: E741\n    QU = 2\n    IQU = 3\n</code></pre>"},{"location":"api_reference/core/compute_GLS_maps/","title":"<code>brahmap.core.compute_GLS_maps</code>","text":"<p>The function to compute the GLS maps given pointing information and TOD</p> <p>Parameters:</p> Name Type Description Default <code>npix</code> <code>int</code> <p>description</p> required <code>pointings</code> <code>ndarray</code> <p>description</p> required <code>time_ordered_data</code> <code>ndarray</code> <p>description</p> required <code>pointings_flag</code> <code>Union[ndarray, None]</code> <p>description, by default None</p> <code>None</code> <code>pol_angles</code> <code>Union[ndarray, None]</code> <p>description, by default None</p> <code>None</code> <code>inv_noise_cov_operator</code> <code>Union[DTypeNoiseCov, None]</code> <p>description, by default None</p> <code>None</code> <code>threshold</code> <code>float</code> <p>description, by default 1.0e-5</p> <code>1e-05</code> <code>dtype_float</code> <code>Union[DTypeFloat, None]</code> <p>description, by default None</p> <code>None</code> <code>update_pointings_inplace</code> <code>bool</code> <p>description, by default True</p> <code>True</code> <code>gls_parameters</code> <code>GLSParameters</code> <p>description, by default GLSParameters()</p> <code>GLSParameters()</code> <p>Returns:</p> Type Description <code>Union[GLSResult, tuple[ProcessTimeSamples, GLSResult]]</code> <p>description</p> Source code in <code>brahmap/core/GLS.py</code> <pre><code>def compute_GLS_maps(\n    npix: int,\n    pointings: np.ndarray,\n    time_ordered_data: np.ndarray,\n    pointings_flag: Union[np.ndarray, None] = None,\n    pol_angles: Union[np.ndarray, None] = None,\n    inv_noise_cov_operator: Union[DTypeNoiseCov, None] = None,\n    threshold: float = 1.0e-5,\n    dtype_float: Union[DTypeFloat, None] = None,\n    update_pointings_inplace: bool = True,\n    gls_parameters: GLSParameters = GLSParameters(),\n) -&gt; Union[GLSResult, tuple[ProcessTimeSamples, GLSResult]]:\n    \"\"\"The function to compute the GLS maps given pointing information and TOD\n\n    Parameters\n    ----------\n    npix : int\n        _description_\n    pointings : np.ndarray\n        _description_\n    time_ordered_data : np.ndarray\n        _description_\n    pointings_flag : Union[np.ndarray, None], optional\n        _description_, by default None\n    pol_angles : Union[np.ndarray, None], optional\n        _description_, by default None\n    inv_noise_cov_operator : Union[DTypeNoiseCov, None], optional\n        _description_, by default None\n    threshold : float, optional\n        _description_, by default 1.0e-5\n    dtype_float : Union[DTypeFloat, None], optional\n        _description_, by default None\n    update_pointings_inplace : bool, optional\n        _description_, by default True\n    gls_parameters : GLSParameters, optional\n        _description_, by default GLSParameters()\n\n    Returns\n    -------\n    Union[GLSResult, tuple[ProcessTimeSamples, GLSResult]]\n        _description_\n    \"\"\"\n    if dtype_float is None:\n        if pol_angles is None:\n            dtype_float = time_ordered_data.dtype\n        else:\n            dtype_float = np.promote_types(pol_angles.dtype, time_ordered_data.dtype)\n\n    if pol_angles is not None:\n        pol_angles = pol_angles.astype(dtype=dtype_float, copy=False)\n\n    if inv_noise_cov_operator is None:\n        noise_weights = None\n    else:\n        noise_weights = inv_noise_cov_operator.diag\n\n    processed_samples = ProcessTimeSamples(\n        npix=npix,\n        pointings=pointings,\n        pointings_flag=pointings_flag,\n        solver_type=gls_parameters.solver_type,\n        pol_angles=pol_angles,\n        noise_weights=noise_weights,\n        threshold=threshold,\n        dtype_float=dtype_float,\n        update_pointings_inplace=update_pointings_inplace,\n    )\n\n    gls_result = compute_GLS_maps_from_PTS(\n        processed_samples=processed_samples,\n        time_ordered_data=time_ordered_data.astype(dtype=dtype_float, copy=False),\n        inv_noise_cov_operator=inv_noise_cov_operator,\n        gls_parameters=gls_parameters,\n    )\n\n    if gls_parameters.return_processed_samples:\n        return processed_samples, gls_result\n    else:\n        del processed_samples\n        gc.collect()\n        return gls_result\n</code></pre>"},{"location":"api_reference/core/compute_GLS_maps_from_PTS/","title":"<code>brahmap.core.compute_GLS_maps_from_PTS</code>","text":"<p>This function computes the GLS maps given an instance of <code>ProcessTimeSamples</code>, TOD, and inverse noise covariance operator</p> <p>Parameters:</p> Name Type Description Default <code>processed_samples</code> <code>ProcessTimeSamples</code> <p>description</p> required <code>time_ordered_data</code> <code>ndarray</code> <p>description</p> required <code>inv_noise_cov_operator</code> <code>Union[DTypeNoiseCov, None]</code> <p>description, by default None</p> <code>None</code> <code>gls_parameters</code> <code>GLSParameters</code> <p>description, by default GLSParameters()</p> <code>GLSParameters()</code> <p>Returns:</p> Type Description <code>GLSResult</code> <p>description</p> Source code in <code>brahmap/core/GLS.py</code> <pre><code>def compute_GLS_maps_from_PTS(\n    processed_samples: ProcessTimeSamples,\n    time_ordered_data: np.ndarray,\n    inv_noise_cov_operator: Union[DTypeNoiseCov, None] = None,\n    gls_parameters: GLSParameters = GLSParameters(),\n) -&gt; GLSResult:\n    \"\"\"This function computes the GLS maps given an instance of\n    `ProcessTimeSamples`, TOD, and inverse noise covariance operator\n\n    Parameters\n    ----------\n    processed_samples : ProcessTimeSamples\n        _description_\n    time_ordered_data : np.ndarray\n        _description_\n    inv_noise_cov_operator : Union[DTypeNoiseCov, None], optional\n        _description_, by default None\n    gls_parameters : GLSParameters, optional\n        _description_, by default GLSParameters()\n\n    Returns\n    -------\n    GLSResult\n        _description_\n    \"\"\"\n    MPI_RAISE_EXCEPTION(\n        condition=(processed_samples.nsamples != len(time_ordered_data)),\n        exception=ValueError,\n        message=f\"Size of `pointings` must be equal to the size of `time_ordered_data` array:\\nlen(pointings) = {processed_samples.nsamples}\\nlen(time_ordered_data) = {len(time_ordered_data)}\",\n    )\n\n    try:\n        time_ordered_data = time_ordered_data.astype(\n            dtype=processed_samples.dtype_float, casting=\"safe\", copy=False\n        )\n    except TypeError:\n        raise TypeError(\n            f\"The `time_ordered_data` array has higher dtype than `processed_samples.dtype_float={processed_samples.dtype_float}`. Please compute `processed_samples` again with `dtype_float={time_ordered_data.dtype}`\"\n        )\n\n    if inv_noise_cov_operator is None:\n        inv_noise_cov_operator = InvNoiseCovLO_Diagonal(\n            size=processed_samples.nsamples, dtype=processed_samples.dtype_float\n        )\n    else:\n        MPI_RAISE_EXCEPTION(\n            condition=(inv_noise_cov_operator.shape[0] != processed_samples.nsamples),\n            exception=ValueError,\n            message=f\"The shape of `inv_noise_cov_operator` must be same as `(len(time_ordered_data), len(time_ordered_data))`:\\nlen(time_ordered_data) = {len(time_ordered_data)}\\ninv_noise_cov_operator.shape = ({inv_noise_cov_operator.shape}, {inv_noise_cov_operator.shape})\",\n        )\n\n    pointing_operator = PointingLO(\n        processed_samples=processed_samples, solver_type=gls_parameters.solver_type\n    )\n\n    blockdiagprecond_operator = BlockDiagonalPreconditionerLO(\n        processed_samples=processed_samples, solver_type=gls_parameters.solver_type\n    )\n\n    b = pointing_operator.T * inv_noise_cov_operator * time_ordered_data\n\n    num_iterations = 0\n    if gls_parameters.use_iterative_solver:\n\n        def callback_function(x, r, norm_residual):\n            nonlocal num_iterations\n            num_iterations += 1\n            if gls_parameters.callback_function is not None:\n                gls_parameters.callback_function(x, r, norm_residual)\n\n        A = pointing_operator.T * inv_noise_cov_operator * pointing_operator\n\n        map_vector, pcg_status = cg(\n            A=A,\n            b=b,\n            atol=gls_parameters.isolver_threshold,\n            maxiter=gls_parameters.isolver_max_iterations,\n            M=blockdiagprecond_operator,\n            callback=callback_function,\n        )\n    else:\n        pcg_status = 0\n        map_vector = blockdiagprecond_operator * b\n\n    output_maps = separate_map_vectors(\n        map_vector=map_vector, processed_samples=processed_samples\n    )\n\n    if gls_parameters.return_hit_map:\n        hit_map = processed_samples.get_hit_counts()\n    else:\n        hit_map = None\n\n    if pcg_status != 0:\n        convergence_status = False\n    else:\n        convergence_status = True\n\n    gls_result = GLSResult(\n        solver_type=processed_samples.solver_type,\n        npix=processed_samples.npix,\n        new_npix=processed_samples.new_npix,\n        GLS_maps=output_maps,\n        hit_map=hit_map,\n        convergence_status=convergence_status,\n        num_iterations=num_iterations,\n        GLSParameters=gls_parameters,\n    )\n\n    return gls_result\n</code></pre>"},{"location":"api_reference/core/separate_map_vectors/","title":"<code>brahmap.core.separate_map_vectors</code>","text":"<p>The output maps of the GLS are in the form [I_1, Q_1, U_1, I_2, Q_2, U_2, ...]. Following the typical conventions, the Stokes parameters have to be separated as [I_1, I_2, ...], [Q_1, Q_2, ...] and [U_1, U_2, ...]. This function performs this operation ane returns the maps of different Stokes parameters separately.</p> <p>Parameters:</p> Name Type Description Default <code>map_vector</code> <code>ndarray</code> <p>description</p> required <code>processed_samples</code> <code>ProcessTimeSamples</code> <p>description</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>description</p> Source code in <code>brahmap/core/GLS.py</code> <pre><code>def separate_map_vectors(\n    map_vector: np.ndarray, processed_samples: ProcessTimeSamples\n) -&gt; np.ndarray:\n    \"\"\"The output maps of the GLS are in the form\n    [I_1, Q_1, U_1, I_2, Q_2, U_2, ...]. Following the typical conventions,\n    the Stokes parameters have to be separated as [I_1, I_2, ...],\n    [Q_1, Q_2, ...] and [U_1, U_2, ...]. This function performs this operation\n    ane returns the maps of different Stokes parameters separately.\n\n    Parameters\n    ----------\n    map_vector : np.ndarray\n        _description_\n    processed_samples : ProcessTimeSamples\n        _description_\n\n    Returns\n    -------\n    np.ndarray\n        _description_\n    \"\"\"\n    try:\n        map_vector = np.reshape(\n            map_vector,\n            shape=(processed_samples.solver_type, processed_samples.new_npix),\n            order=\"F\",\n        )\n    except TypeError:\n        # `newshape` parameter has been deprecated since numpy 2.1.0. This part should be removed once the support is dropped for lower version\n        map_vector = np.reshape(\n            map_vector,\n            newshape=(processed_samples.solver_type, processed_samples.new_npix),\n            order=\"F\",\n        )\n\n    output_maps = np.ma.MaskedArray(\n        data=np.empty(processed_samples.npix, dtype=processed_samples.dtype_float),\n        mask=~processed_samples.pixel_flag,\n        fill_value=-1.6375e30,\n    )\n\n    output_maps = np.tile(A=output_maps, reps=(processed_samples.solver_type, 1))\n\n    for idx in range(processed_samples.solver_type):\n        output_maps[idx][~output_maps[idx].mask] = map_vector[idx]\n\n    return output_maps\n</code></pre>"},{"location":"api_reference/lbsim/","title":"<code>litebird_sim</code> Interface","text":""},{"location":"api_reference/lbsim/#data-pre-processing","title":"Data pre-processing","text":"<ul> <li><code>LBSimProcessTimeSamples</code></li> </ul>"},{"location":"api_reference/lbsim/#noise-covariance-and-their-inverse-operators","title":"Noise covariance (and their inverse) operators","text":"<ul> <li><code>LBSim_InvNoiseCovLO_UnCorr</code></li> <li><code>LBSim_InvNoiseCovLO_Circulant</code></li> <li><code>LBSim_InvNoiseCovLO_Toeplitz</code></li> </ul>"},{"location":"api_reference/lbsim/#gls-map-making-functions-and-tools","title":"GLS map-making functions and tools","text":"<ul> <li><code>LBSimGLSParameters</code></li> <li><code>LBSim_compute_GLS_maps</code></li> <li><code>LBSimGLSResult</code></li> </ul>"},{"location":"api_reference/lbsim/LBSimGLSParameters/","title":"<code>brahmap.lbsim.LBSimGLSParameters</code>","text":"<p>               Bases: <code>GLSParameters</code></p> <p>A class to encapsulate the parameters used for GLS map-making with <code>litebird_sim</code> data</p> <p>Parameters:</p> Name Type Description Default <code>solver_type</code> <code>SolverType</code> <p>description</p> <code>IQU</code> <code>use_iterative_solver</code> <code>bool</code> <p>description</p> <code>True</code> <code>isolver_threshold</code> <code>float</code> <p>description</p> <code>1e-12</code> <code>isolver_max_iterations</code> <code>int</code> <p>description</p> <code>100</code> <code>callback_function</code> <code>Callable</code> <p>description</p> <code>None</code> <code>return_processed_samples</code> <code>bool</code> <p>description</p> <code>False</code> <code>return_hit_map</code> <code>bool</code> <p>description</p> <code>False</code> <code>return_processed_samples</code> <code>bool</code> <p>description</p> <code>False</code> <code>output_coordinate_system</code> <code>CoordinateSystem</code> <p>description</p> <code>Galactic</code> Source code in <code>brahmap/lbsim/lbsim_GLS.py</code> <pre><code>@dataclass\nclass LBSimGLSParameters(GLSParameters):\n    \"\"\"A class to encapsulate the parameters used for GLS map-making with\n    `litebird_sim` data\n\n    Parameters\n    ----------\n    solver_type : SolverType\n        _description_\n    use_iterative_solver : bool\n        _description_\n    isolver_threshold : float\n        _description_\n    isolver_max_iterations : int\n        _description_\n    callback_function : Callable\n        _description_\n    return_processed_samples : bool\n        _description_\n    return_hit_map : bool\n        _description_\n    return_processed_samples : bool\n        _description_\n    output_coordinate_system : lbs.CoordinateSystem\n        _description_\n    \"\"\"\n\n    return_processed_samples: bool = False\n    output_coordinate_system: lbs.CoordinateSystem = lbs.CoordinateSystem.Galactic\n</code></pre>"},{"location":"api_reference/lbsim/LBSimGLSResult/","title":"<code>brahmap.lbsim.LBSimGLSResult</code>","text":"<p>               Bases: <code>GLSResult</code></p> <p>A class to store the results of the GLs map-making done with <code>litebird_sim</code> data</p> <p>Parameters:</p> Name Type Description Default <code>solver_type</code> <code>SolverType</code> <p>description</p> required <code>npix</code> <code>int</code> <p>description</p> required <code>new_npix</code> <code>int</code> <p>description</p> required <code>GLS_maps</code> <code>ndarray</code> <p>description</p> required <code>hit_map</code> <code>ndarray</code> <p>description</p> required <code>convergence_status</code> <code>bool</code> <p>description</p> required <code>num_iterations</code> <code>int</code> <p>description</p> required <code>GLSParameters</code> <code>GLSParameters</code> <p>description</p> required <code>nside</code> <code>int</code> <p>description</p> required <code>coordinate_system</code> <code>CoordinateSystem</code> <p>description</p> required Source code in <code>brahmap/lbsim/lbsim_GLS.py</code> <pre><code>@dataclass\nclass LBSimGLSResult(GLSResult):\n    \"\"\"A class to store the results of the GLs map-making done with `litebird_sim` data\n\n    Parameters\n    ----------\n    solver_type : SolverType\n        _description_\n    npix : int\n        _description_\n    new_npix : int\n        _description_\n    GLS_maps : np.ndarray\n        _description_\n    hit_map : np.ndarray\n        _description_\n    convergence_status : bool\n        _description_\n    num_iterations : int\n        _description_\n    GLSParameters : GLSParameters\n        _description_\n    nside : int\n        _description_\n    coordinate_system : lbs.CoordinateSystem\n        _description_\n    \"\"\"\n\n    nside: int\n    coordinate_system: lbs.CoordinateSystem\n</code></pre>"},{"location":"api_reference/lbsim/LBSimProcessTimeSamples/","title":"<code>brahmap.lbsim.LBSimProcessTimeSamples</code>","text":"<p>               Bases: <code>ProcessTimeSamples</code></p> <p>A class to store the pre-processed and pre-computed arrays from <code>litebird_sim</code> observations.</p> <p>Parameters:</p> Name Type Description Default <code>nside</code> <code>int</code> <p>Nside of the healpix map</p> required <code>observations</code> <code>Union[Observation, List[Observation]]</code> <p>An instance of the <code>Observation</code> class or a list of the same</p> required <code>pointings</code> <code>Union[ndarray, List[ndarray], None]</code> <p>description, by default None</p> <code>None</code> <code>hwp</code> <code>Optional[HWP]</code> <p>description, by default None</p> <code>None</code> <code>pointings_flag</code> <code>Optional[ndarray]</code> <p>description, by default None</p> <code>None</code> <code>solver_type</code> <code>SolverType</code> <p>description, by default SolverType.IQU</p> <code>IQU</code> <code>noise_weights</code> <code>Optional[ndarray]</code> <p>description, by default None</p> <code>None</code> <code>output_coordinate_system</code> <code>CoordinateSystem</code> <p>description, by default lbs.CoordinateSystem.Galactic</p> <code>Galactic</code> <code>threshold</code> <code>float</code> <p>description, by default 1.0e-5</p> <code>1e-05</code> <code>dtype_float</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/lbsim/lbsim_process_time_samples.py</code> <pre><code>class LBSimProcessTimeSamples(ProcessTimeSamples):\n    \"\"\"A class to store the pre-processed and pre-computed arrays from `litebird_sim` observations.\n\n    Parameters\n    ----------\n    nside : int\n        Nside of the healpix map\n    observations : Union[lbs.Observation, List[lbs.Observation]]\n        An instance of the `Observation` class or a list of the same\n    pointings : Union[np.ndarray, List[np.ndarray], None], optional\n        _description_, by default None\n    hwp : Optional[lbs.HWP], optional\n        _description_, by default None\n    pointings_flag : Optional[np.ndarray], optional\n        _description_, by default None\n    solver_type : SolverType, optional\n        _description_, by default SolverType.IQU\n    noise_weights : Optional[np.ndarray], optional\n        _description_, by default None\n    output_coordinate_system : lbs.CoordinateSystem, optional\n        _description_, by default lbs.CoordinateSystem.Galactic\n    threshold : float, optional\n        _description_, by default 1.0e-5\n    dtype_float : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n    def __init__(\n        self,\n        nside: int,\n        observations: Union[lbs.Observation, List[lbs.Observation]],\n        pointings: Union[np.ndarray, List[np.ndarray], None] = None,\n        hwp: Optional[lbs.HWP] = None,\n        pointings_flag: Optional[np.ndarray] = None,\n        solver_type: SolverType = SolverType.IQU,\n        noise_weights: Optional[np.ndarray] = None,\n        output_coordinate_system: lbs.CoordinateSystem = lbs.CoordinateSystem.Galactic,\n        threshold: float = 1.0e-5,\n        dtype_float: DTypeFloat = np.float64,\n    ):\n        self.__nside = nside\n        self.__coordinate_system = output_coordinate_system\n        npix = hp.nside2npix(self.nside)\n\n        (\n            self.__obs_list,\n            ptg_list,\n        ) = lbs.pointings_in_obs._normalize_observations_and_pointings(\n            observations=observations, pointings=pointings\n        )\n\n        num_total_samples = 0\n        for obs in self.obs_list:\n            num_total_samples += obs.n_detectors * obs.n_samples\n\n        pix_indices = np.empty(num_total_samples, dtype=int)\n        pol_angles = np.empty(num_total_samples, dtype=dtype_float)\n\n        start_idx = 0\n        end_idx = 0\n        for obs_idx, (obs, curr_pointings) in enumerate(zip(self.obs_list, ptg_list)):\n            if hwp is None:\n                hwp_angle = None\n            else:\n                hwp_angle = lbs.pointings_in_obs._get_hwp_angle(\n                    obs=obs, hwp=hwp, pointing_dtype=dtype_float\n                )\n\n            for det_idx in range(obs.n_detectors):\n                (\n                    curr_pointings_det,\n                    hwp_angle,\n                ) = lbs.pointings_in_obs._get_pointings_array(\n                    detector_idx=det_idx,\n                    pointings=curr_pointings,\n                    hwp_angle=hwp_angle,\n                    output_coordinate_system=output_coordinate_system,\n                    pointings_dtype=dtype_float,\n                )\n\n                end_idx += obs.n_samples\n\n                pol_angles[start_idx:end_idx] = lbs.pointings_in_obs._get_pol_angle(\n                    curr_pointings_det=curr_pointings_det,\n                    hwp_angle=hwp_angle,\n                    pol_angle_detectors=obs.pol_angle_rad[det_idx],\n                )\n\n                pix_indices[start_idx:end_idx] = hp.ang2pix(\n                    nside, curr_pointings_det[:, 0], curr_pointings_det[:, 1]\n                )\n\n                start_idx = end_idx\n\n            del hwp_angle, curr_pointings_det\n\n        del curr_pointings\n\n        super().__init__(\n            npix=npix,\n            pointings=pix_indices,\n            pointings_flag=pointings_flag,\n            solver_type=solver_type,\n            pol_angles=pol_angles,\n            noise_weights=noise_weights,\n            threshold=threshold,\n            dtype_float=dtype_float,\n            update_pointings_inplace=True,\n        )\n\n    @property\n    def obs_list(self):\n        \"\"\"List of the instances of `Observation` class\"\"\"\n        return self.__obs_list\n\n    @property\n    def nside(self):\n        \"\"\"Nside parameter of the healpix map\"\"\"\n        return self.__nside\n\n    @property\n    def coordinate_system(self):\n        \"\"\"Coordinate system used in data-processing\"\"\"\n        return self.__coordinate_system\n</code></pre>"},{"location":"api_reference/lbsim/LBSimProcessTimeSamples/#brahmap.lbsim.LBSimProcessTimeSamples.coordinate_system","title":"<code>coordinate_system</code>  <code>property</code>","text":"<p>Coordinate system used in data-processing</p>"},{"location":"api_reference/lbsim/LBSimProcessTimeSamples/#brahmap.lbsim.LBSimProcessTimeSamples.nside","title":"<code>nside</code>  <code>property</code>","text":"<p>Nside parameter of the healpix map</p>"},{"location":"api_reference/lbsim/LBSimProcessTimeSamples/#brahmap.lbsim.LBSimProcessTimeSamples.obs_list","title":"<code>obs_list</code>  <code>property</code>","text":"<p>List of the instances of <code>Observation</code> class</p>"},{"location":"api_reference/lbsim/LBSim_InvNoiseCovLO_Circulant/","title":"<code>brahmap.lbsim.LBSim_InvNoiseCovLO_Circulant</code>","text":"<p>               Bases: <code>BlockDiagInvNoiseCovLO</code></p> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Union[Observation, List[Observation]]</code> <p>description</p> required <code>input</code> <code>Union[dict, Union[ndarray, List]]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/lbsim/lbsim_noise_operators.py</code> <pre><code>class LBSim_InvNoiseCovLO_Circulant(BlockDiagInvNoiseCovLO):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    obs : Union[lbs.Observation, List[lbs.Observation]]\n        _description_\n    input : Union[dict, Union[np.ndarray, List]]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    def __init__(\n        self,\n        obs: Union[lbs.Observation, List[lbs.Observation]],\n        input: Union[dict, Union[np.ndarray, List]],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        dtype: DTypeFloat = np.float64,\n    ):\n        if isinstance(obs, lbs.Observation):\n            obs_list = [obs]\n        else:\n            obs_list = obs\n\n        block_size = []\n\n        if isinstance(input, dict):\n            block_input = []\n\n            for obs in obs_list:\n                # if input is a dict\n                for det_idx in range(obs.n_detectors):\n                    block_size.append(obs.n_samples)\n\n                    resized_input = self.__resize_input(\n                        new_size=obs.n_samples,\n                        input=input[obs.name[det_idx]],\n                        input_type=input_type,\n                        dtype=dtype,\n                    )\n\n                    block_input.append(resized_input)\n\n        elif isinstance(input, (np.ndarray, list)):\n            block_input = {}\n\n            for obs in obs_list:\n                for det_idx in range(obs.n_detectors):\n                    # if input is an array or a list, it will be taken as same for all the detectors available in the observation\n                    block_size.append(obs.n_samples)\n\n                    if obs.n_samples not in block_input.keys():\n                        resized_input = self.__resize_input(\n                            new_size=obs.n_samples,\n                            input=input,\n                            input_type=input_type,\n                            dtype=dtype,\n                        )\n\n                        block_input[obs.n_samples] = resized_input\n        else:\n            MPI_RAISE_EXCEPTION(\n                condition=True,\n                exception=ValueError,\n                message=\"The input must be an array or a list or a dictionary that maps detector names to their covariance/power spectrum\",\n            )\n\n        super(LBSim_InvNoiseCovLO_Circulant, self).__init__(\n            InvNoiseCovLO_Circulant,\n            block_size=block_size,\n            block_input=block_input,\n            input_type=input_type,\n            dtype=dtype,\n        )\n\n    def __resize_input(self, new_size, input, input_type, dtype):\n        if input_type == \"covariance\":\n            # if the size of the returned array is smaller than new_size, it\n            # will be captured by the InvNoiseCovLO_Circulant class\n            # automatically\n\n            # Slicing the input array here is probably not the best choice as\n            # it breaks the symmetry of the covariance and renders it\n            # non-circulant. Same goes for slicing the covariance computed\n            # through power spectrum. The best solution would be to create per\n            # observation, per detector operators independently and supply them\n            # to `BlockDiagInvNoiseCovLO`\n            return input[:new_size]\n        elif input_type == \"power_spectrum\":\n            input_size = len(input)\n            if input_size &gt; new_size:\n                new_input = np.fft.ifft(input)[:new_size]  # new covariance\n                new_input = np.fft.fft(new_input).real.astype(\n                    dtype=dtype,\n                    copy=False,\n                )  # new ps\n                return new_input\n            else:\n                # If input size is equal to expected size, it will be fine.\n                # If it is smaller, InvNoiseCovLO_Circulant class will\n                # throw an error automatically\n                return input\n</code></pre>"},{"location":"api_reference/lbsim/LBSim_InvNoiseCovLO_Toeplitz/","title":"<code>brahmap.lbsim.LBSim_InvNoiseCovLO_Toeplitz</code>","text":"<p>               Bases: <code>BlockDiagInvNoiseCovLO</code></p> <p>summary</p> <p>Note that the observation length is either n or n-1.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Union[Observation, List[Observation]]</code> <p>description</p> required <code>input</code> <code>Union[dict, Union[ndarray, List]]</code> <p>description</p> required <code>input_type</code> <code>Literal['covariance', 'power_spectrum']</code> <p>description, by default \"power_spectrum\"</p> <code>'power_spectrum'</code> <code>operator</code> <code>InvNoiseCovLinearOperator</code> <p>description, by default InvNoiseCovLO_Toeplitz01</p> <code>InvNoiseCovLO_Toeplitz01</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> <code>extra_kwargs</code> <code>Dict[str, Any]</code> <p>description, by default {}</p> <code>{}</code> Source code in <code>brahmap/lbsim/lbsim_noise_operators.py</code> <pre><code>class LBSim_InvNoiseCovLO_Toeplitz(BlockDiagInvNoiseCovLO):\n    \"\"\"_summary_\n\n    Note that the observation length is either n or n-1.\n\n    Parameters\n    ----------\n    obs : Union[lbs.Observation, List[lbs.Observation]]\n        _description_\n    input : Union[dict, Union[np.ndarray, List]]\n        _description_\n    input_type : Literal[\"covariance\", \"power_spectrum\"], optional\n        _description_, by default \"power_spectrum\"\n    operator : InvNoiseCovLinearOperator, optional\n        _description_, by default InvNoiseCovLO_Toeplitz01\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    extra_kwargs : Dict[str, Any], optional\n        _description_, by default {}\n    \"\"\"\n\n    def __init__(\n        self,\n        obs: Union[lbs.Observation, List[lbs.Observation]],\n        input: Union[dict, Union[np.ndarray, List]],\n        input_type: Literal[\"covariance\", \"power_spectrum\"] = \"power_spectrum\",\n        operator: InvNoiseCovLinearOperator = InvNoiseCovLO_Toeplitz01,\n        dtype: DTypeFloat = np.float64,\n        extra_kwargs: Dict[str, Any] = {},\n    ):\n        if isinstance(obs, lbs.Observation):\n            obs_list = [obs]\n        else:\n            obs_list = obs\n\n        block_size = []\n\n        if isinstance(input, dict):\n            block_input = []\n\n            for obs in obs_list:\n                # if input is a dict\n                for det_idx in range(obs.n_detectors):\n                    block_size.append(obs.n_samples)\n\n                    resized_input = self.__resize_input(\n                        new_size=obs.n_samples,\n                        input=input[obs.name[det_idx]],\n                        input_type=input_type,\n                        dtype=dtype,\n                    )\n\n                    block_input.append(resized_input)\n\n        elif isinstance(input, (np.ndarray, list)):\n            block_input = {}\n\n            for obs in obs_list:\n                for det_idx in range(obs.n_detectors):\n                    # if input is an array or a list, it will be taken as same for all the detectors available in the observation\n                    block_size.append(obs.n_samples)\n\n                    if obs.n_samples not in block_input.keys():\n                        resized_input = self.__resize_input(\n                            new_size=obs.n_samples,\n                            input=input,\n                            input_type=input_type,\n                            dtype=dtype,\n                        )\n\n                        block_input[obs.n_samples] = resized_input\n        else:\n            MPI_RAISE_EXCEPTION(\n                condition=True,\n                exception=ValueError,\n                message=\"The input must be an array or a list or a dictionary that maps detector names to their covariance/power spectrum\",\n            )\n\n        super(LBSim_InvNoiseCovLO_Toeplitz, self).__init__(\n            operator,\n            block_size=block_size,\n            block_input=block_input,\n            input_type=input_type,\n            dtype=dtype,\n            extra_kwargs=extra_kwargs,\n        )\n\n    def __resize_input(self, new_size, input, input_type, dtype):\n        if input_type == \"covariance\":\n            # if the size of the returned array is smaller than new_size, it\n            # will be captured by the InvNoiseCovLO_Toeplitz0x class\n            # automatically\n            return input[:new_size]\n        elif input_type == \"power_spectrum\":\n            input_size = len(input)\n            ex_size1 = 2 * new_size - 1  # expected size of ps array (2n-1)\n            ex_size2 = 2 * new_size - 2  # expected size of ps array (2n-2)\n            if input_size &gt; ex_size2 and input_size &gt; ex_size1:\n                new_input = np.fft.ifft(input)[\n                    :new_size\n                ]  # covariance of size `new_size`\n                new_input = np.concatenate(\n                    [new_input, new_input[1:-1][::-1]]\n                )  # full covariance of size `2*new_size - 2`\n                new_input = np.fft.fft(new_input).real.astype(\n                    dtype=dtype, copy=False\n                )  # full ps of size `2*new_size - 2`\n                return new_input\n            else:\n                # If input size is equal to expected size, it will be fine.\n                # If it is smaller, InvNoiseCovLO_Toeplitz0x class will\n                # throw an error automatically\n                return input\n</code></pre>"},{"location":"api_reference/lbsim/LBSim_InvNoiseCovLO_UnCorr/","title":"<code>brahmap.lbsim.LBSim_InvNoiseCovLO_UnCorr</code>","text":"<p>               Bases: <code>BlockDiagInvNoiseCovLO</code></p> <p>summary</p> <p>The assumption is that at a given MPI process, all observations contain same set of detectors</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Union[Observation, List[Observation]]</code> <p>description</p> required <code>noise_variance</code> <code>Union[dict, DTypeFloat, None]</code> <p>description, by default None</p> <code>None</code> <code>dtype</code> <code>DTypeFloat</code> <p>description, by default np.float64</p> <code>float64</code> Source code in <code>brahmap/lbsim/lbsim_noise_operators.py</code> <pre><code>class LBSim_InvNoiseCovLO_UnCorr(BlockDiagInvNoiseCovLO):\n    \"\"\"_summary_\n\n    The assumption is that at a given MPI process, all observations\n    contain same set of detectors\n\n    Parameters\n    ----------\n    obs : Union[lbs.Observation, List[lbs.Observation]]\n        _description_\n    noise_variance : Union[dict, DTypeFloat, None], optional\n        _description_, by default None\n    dtype : DTypeFloat, optional\n        _description_, by default np.float64\n    \"\"\"\n\n    # Keep a note of the hard-coded factor of 1e4\n\n    def __init__(\n        self,\n        obs: Union[lbs.Observation, List[lbs.Observation]],\n        noise_variance: Union[dict, DTypeFloat, None] = None,\n        dtype: DTypeFloat = np.float64,\n    ):\n        if isinstance(obs, lbs.Observation):\n            obs_list = [obs]\n        else:\n            obs_list = obs\n\n        if noise_variance is None:\n            noise_variance = dict(\n                zip(\n                    obs_list[0].name,\n                    lbs.mapmaking.common.get_map_making_weights(obs_list[0]) / 1.0e4,\n                )\n            )\n        elif isinstance(noise_variance, numbers.Number):\n            noise_variance = dict(\n                zip(\n                    obs_list[0].name,\n                    [noise_variance] * len(obs_list[0].name),\n                )\n            )\n\n        # setting the `noise_variance` to 1 for the detectors whose noise variance is not provided in the dictionary\n        det_no_variance = np.setdiff1d(obs_list[0].name, list(noise_variance.keys()))\n        for detector in det_no_variance:\n            noise_variance[detector] = 1.0\n\n        block_size = []\n\n        if len(set(noise_variance.values())) == 1:\n            # That is, when all values in noise variance is the same\n            block_input = {}\n            for obs in obs_list:\n                for det_idx in range(obs.n_detectors):\n                    block_size.append(obs.n_samples)\n                    if obs.n_samples not in block_input.keys():\n                        block_input[obs.n_samples] = noise_variance[obs.name[0]]\n        else:\n            block_input = []\n            for obs in obs_list:\n                for det_idx in range(obs.n_detectors):\n                    block_size.append(obs.n_samples)\n                    block_input.append(noise_variance[obs.name[det_idx]])\n\n        super(LBSim_InvNoiseCovLO_UnCorr, self).__init__(\n            InvNoiseCovLO_Diagonal,\n            block_size=block_size,\n            block_input=block_input,\n            input_type=\"covariance\",\n            dtype=dtype,\n        )\n</code></pre>"},{"location":"api_reference/lbsim/LBSim_compute_GLS_maps/","title":"<code>brahmap.lbsim.LBSim_compute_GLS_maps</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>nside</code> <code>int</code> <p>description</p> required <code>observations</code> <code>Union[Observation, List[Observation]]</code> <p>description</p> required <code>pointings</code> <code>Union[ndarray, List[ndarray], None]</code> <p>description, by default None</p> <code>None</code> <code>hwp</code> <code>Optional[HWP]</code> <p>description, by default None</p> <code>None</code> <code>components</code> <code>Union[str, List[str]]</code> <p>description, by default \"tod\"</p> <code>'tod'</code> <code>pointings_flag</code> <code>Optional[ndarray]</code> <p>description, by default None</p> <code>None</code> <code>inv_noise_cov_operator</code> <code>Union[DTypeNoiseCov, DTypeLBSNoiseCov, None]</code> <p>description, by default None</p> <code>None</code> <code>threshold</code> <code>float</code> <p>description, by default 1.0e-5</p> <code>1e-05</code> <code>dtype_float</code> <code>Optional[DTypeFloat]</code> <p>description, by default None</p> <code>None</code> <code>LBSim_gls_parameters</code> <code>LBSimGLSParameters</code> <p>description, by default LBSimGLSParameters()</p> <code>LBSimGLSParameters()</code> <p>Returns:</p> Type Description <code>Union[LBSimGLSResult, tuple[LBSimProcessTimeSamples, LBSimGLSResult]]</code> <p>description</p> Source code in <code>brahmap/lbsim/lbsim_GLS.py</code> <pre><code>def LBSim_compute_GLS_maps(\n    nside: int,\n    observations: Union[lbs.Observation, List[lbs.Observation]],\n    pointings: Union[np.ndarray, List[np.ndarray], None] = None,\n    hwp: Optional[lbs.HWP] = None,\n    components: Union[str, List[str]] = \"tod\",\n    pointings_flag: Optional[np.ndarray] = None,\n    inv_noise_cov_operator: Union[DTypeNoiseCov, DTypeLBSNoiseCov, None] = None,\n    threshold: float = 1.0e-5,\n    dtype_float: Optional[DTypeFloat] = None,\n    LBSim_gls_parameters: LBSimGLSParameters = LBSimGLSParameters(),\n) -&gt; Union[LBSimGLSResult, tuple[LBSimProcessTimeSamples, LBSimGLSResult]]:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    nside : int\n        _description_\n    observations : Union[lbs.Observation, List[lbs.Observation]]\n        _description_\n    pointings : Union[np.ndarray, List[np.ndarray], None], optional\n        _description_, by default None\n    hwp : Optional[lbs.HWP], optional\n        _description_, by default None\n    components : Union[str, List[str]], optional\n        _description_, by default \"tod\"\n    pointings_flag : Optional[np.ndarray], optional\n        _description_, by default None\n    inv_noise_cov_operator : Union[DTypeNoiseCov, DTypeLBSNoiseCov, None], optional\n        _description_, by default None\n    threshold : float, optional\n        _description_, by default 1.0e-5\n    dtype_float : Optional[DTypeFloat], optional\n        _description_, by default None\n    LBSim_gls_parameters : LBSimGLSParameters, optional\n        _description_, by default LBSimGLSParameters()\n\n    Returns\n    -------\n    Union[LBSimGLSResult, tuple[LBSimProcessTimeSamples, LBSimGLSResult]]\n        _description_\n    \"\"\"\n    if inv_noise_cov_operator is None:\n        noise_weights = None\n    else:\n        noise_weights = inv_noise_cov_operator.diag\n\n    processed_samples = LBSimProcessTimeSamples(\n        nside=nside,\n        observations=observations,\n        pointings=pointings,\n        hwp=hwp,\n        pointings_flag=pointings_flag,\n        solver_type=LBSim_gls_parameters.solver_type,\n        noise_weights=noise_weights,\n        output_coordinate_system=LBSim_gls_parameters.output_coordinate_system,\n        threshold=threshold,\n        dtype_float=dtype_float,\n    )\n\n    if isinstance(components, str):\n        components = [components]\n\n    if len(components) &gt; 1:\n        lbs.mapmaking.destriper._sum_components_into_obs(\n            obs_list=processed_samples.obs_list,\n            target=components[0],\n            other_components=components[1:],\n            factor=1.0,\n        )\n\n    time_ordered_data = np.concatenate(\n        [getattr(obs, components[0]) for obs in processed_samples.obs_list], axis=None\n    )\n\n    gls_result = compute_GLS_maps_from_PTS(\n        processed_samples=processed_samples,\n        time_ordered_data=time_ordered_data,\n        inv_noise_cov_operator=inv_noise_cov_operator,\n        gls_parameters=LBSim_gls_parameters,\n    )\n\n    gls_result = LBSimGLSResult(\n        nside=nside,\n        coordinate_system=LBSim_gls_parameters.output_coordinate_system,\n        **asdict(gls_result),\n    )\n\n    if LBSim_gls_parameters.return_processed_samples:\n        return processed_samples, gls_result\n    else:\n        del processed_samples\n        gc.collect()\n        return gls_result\n</code></pre>"},{"location":"api_reference/math_functions/","title":"Math Functions","text":""},{"location":"api_reference/math_functions/#linear-algebra","title":"Linear algebra","text":"<ul> <li><code>parallel_norm</code></li> <li><code>cg</code></li> </ul>"},{"location":"api_reference/math_functions/#unary-functions","title":"Unary functions","text":"<p>These functions are element-wise unary functions, and have common signature:</p> <pre><code>function_name(\n    size,     # size of the input/output array\n    vec,      # input array\n    result,   # output array containing the result (overwritten)\n)\n</code></pre> <p>Following functions are available:</p> <ul> <li><code>brahmap.math.sin</code>: sine function</li> <li><code>brahmap.math.cos</code>: cosine function</li> <li><code>brahmap.math.tan</code>: tangent function</li> <li><code>brahmap.math.asin</code>: arcsine function</li> <li><code>brahmap.math.acos</code>: arccosine function</li> <li><code>brahmap.math.atan</code>: arctangent function</li> <li><code>brahmap.math.exp</code>: exponential function, \\(e^x\\)</li> <li><code>brahmap.math.exp2</code>: exponential function with base 2, \\(2^x\\)</li> <li><code>brahmap.math.log</code>: natural logarithm function</li> <li><code>brahmap.math.log2</code>: base-2 logarithm function</li> <li><code>brahmap.math.sqrt</code>: square-root function</li> <li><code>brahmap.math.cbrt</code>: cube-root function</li> </ul>"},{"location":"api_reference/math_functions/#dtype-hints","title":"<code>dtype</code> hints","text":"<ul> <li><code>DTypeFloat</code>: type-hint for the <code>dtype</code> of floating-point numbers</li> <li><code>DTypeInt</code>: type-hint for the <code>dtype</code> of signed integers</li> <li><code>DTypeUInit</code>: type-hint for the <code>dtype</code> of unsigned integers</li> <li><code>DTypeBool</code>: type-hint for the <code>dtype</code> of bools</li> </ul>"},{"location":"api_reference/math_functions/cg/","title":"<code>brahmap.math.cg</code>","text":"<p>A replacement of <code>scipy.sparse.linalg.cg</code> where <code>np.linalg.norm</code> is replaced with <code>brahmap.math.parallel_norm</code> when the parameter <code>parallel</code> is set <code>True</code></p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>LinearOperator</code> <p>description</p> required <code>b</code> <code>ndarray</code> <p>description</p> required <code>x0</code> <code>ndarray</code> <p>description, by default None</p> <code>None</code> <code>atol</code> <code>float</code> <p>description, by default 1.0e-12</p> <code>1e-12</code> <code>maxiter</code> <code>int</code> <p>description, by default 100</p> <code>100</code> <code>M</code> <code>LinearOperator</code> <p>description, by default None</p> <code>None</code> <code>callback</code> <code>Callable</code> <p>description, by default None</p> <code>None</code> <code>parallel</code> <code>bool</code> <p>description, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p> Source code in <code>brahmap/math/linalg.py</code> <pre><code>def cg(\n    A: LinearOperator,\n    b: np.ndarray,\n    x0: np.ndarray = None,\n    atol: float = 1.0e-12,\n    maxiter: int = 100,\n    M: LinearOperator = None,\n    callback: Callable = None,\n    parallel: bool = True,\n):\n    \"\"\"A replacement of `scipy.sparse.linalg.cg` where `np.linalg.norm` is\n    replaced with `brahmap.math.parallel_norm` when the parameter `parallel`\n    is set `True`\n\n    Parameters\n    ----------\n    A : LinearOperator\n        _description_\n    b : np.ndarray\n        _description_\n    x0 : np.ndarray, optional\n        _description_, by default None\n    atol : float, optional\n        _description_, by default 1.0e-12\n    maxiter : int, optional\n        _description_, by default 100\n    M : LinearOperator, optional\n        _description_, by default None\n    callback : Callable, optional\n        _description_, by default None\n    parallel : bool, optional\n        _description_, by default True\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    temp_tuple = scipy.sparse.linalg._isolve.utils.make_system(\n        A,\n        M,\n        x0,\n        b,\n    )\n\n    # Starting from SciPy 1.16.0, `make_system` returns 4 objects instead of 5.\n    # Even in earlier versions, only the first 4 objects were needed for our\n    # use. The following unpacking ensures compatibility across all versions.\n    # This logic can be simplified once support for versions below 1.16.0 is\n    # dropped.\n    A = temp_tuple[0]\n    M = temp_tuple[1]\n    x = temp_tuple[2]\n    b = temp_tuple[3]\n\n    if parallel:\n        norm_function: Callable = parallel_norm\n    else:\n        norm_function: Callable = np.linalg.norm\n\n    b_norm = norm_function(b)\n\n    if b_norm == 0:\n        return b, 0\n\n    dotprod = np.vdot if np.iscomplexobj(x) else np.dot\n\n    # r = b - A@x if x has any non-zero element, otherwise r = b\n    r = b - A * x if x.any() else b.copy()\n\n    # Dummy initialization\n    rho_prev, p = None, None\n\n    norm_residual = 1.0\n\n    for iteration in range(maxiter):\n        if norm_residual &lt; atol:\n            return x, 0\n\n        z = M * r\n        rho_cur = dotprod(r, z)\n        if iteration &gt; 0:\n            beta = rho_cur / rho_prev\n            p *= beta\n            p += z\n        else:\n            p = np.empty_like(r)\n            p[:] = z[:]\n\n        q = A * p\n        alpha = rho_cur / dotprod(p, q)\n        x += alpha * p\n        r -= alpha * q\n        rho_prev = rho_cur\n\n        norm_residual = norm_function(r) / b_norm\n\n        if callback:\n            callback(x, r, norm_residual)\n\n    else:\n        return x, maxiter\n</code></pre>"},{"location":"api_reference/math_functions/parallel_norm/","title":"<code>brahmap.math.parallel_norm</code>","text":"<p>A replacement of <code>np.linalg.norm</code> to compute 2-norm of a vector distributed among multiple MPI processes</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Input array</p> required <p>Returns:</p> Type Description <code>float</code> <p>The norm of vector <code>x</code></p> Source code in <code>brahmap/math/linalg.py</code> <pre><code>def parallel_norm(x: np.ndarray) -&gt; float:\n    \"\"\"A replacement of `np.linalg.norm` to compute 2-norm of a vector\n    distributed among multiple MPI processes\n\n    Parameters\n    ----------\n    x : np.ndarray\n        Input array\n\n    Returns\n    -------\n    float\n        The norm of vector `x`\n    \"\"\"\n    sqnorm = x.dot(x)\n    sqnorm = MPI_UTILS.comm.allreduce(sqnorm)\n    ret = np.sqrt(sqnorm)\n    return ret\n</code></pre>"},{"location":"api_reference/misc/","title":"Miscellaneous","text":"<ul> <li><code>TypeChangeWarning</code></li> <li><code>LowerTypeCastWarning</code></li> <li><code>filter_warnings</code></li> <li><code>ShapeError</code></li> </ul>"},{"location":"api_reference/misc/LowerTypeCastWarning/","title":"<code>brahmap.base.LowerTypeCastWarning</code>","text":"<p>               Bases: <code>Warning</code></p> Source code in <code>brahmap/base/misc.py</code> <pre><code>class LowerTypeCastWarning(Warning):\n    def __init__(self, message):\n        self.message = message\n\n    def __str__(self):\n        return repr(self.message)\n</code></pre>"},{"location":"api_reference/misc/ShapeError/","title":"<code>brahmap.base.ShapeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for handling shape mismatch errors.</p> <p>Exception raised when defining a linear operator of the wrong shape or multiplying a linear operator with a vector of the wrong shape.</p> Source code in <code>brahmap/base/misc.py</code> <pre><code>class ShapeError(Exception):\n    \"\"\"\n    Exception class for handling shape mismatch errors.\n\n    Exception raised when defining a linear operator of the wrong shape or\n    multiplying a linear operator with a vector of the wrong shape.\n\n    \"\"\"\n\n    def __init__(self, value):\n        super(ShapeError, self).__init__()\n        self.value = value\n\n    def __str__(self):\n        return repr(self.value)\n</code></pre>"},{"location":"api_reference/misc/TypeChangeWarning/","title":"<code>brahmap.base.TypeChangeWarning</code>","text":"<p>               Bases: <code>Warning</code></p> Source code in <code>brahmap/base/misc.py</code> <pre><code>class TypeChangeWarning(Warning):\n    def __init__(self, message):\n        self.message = message\n\n    def __str__(self):\n        return repr(self.message)\n</code></pre>"},{"location":"api_reference/misc/filter_warnings/","title":"<code>brahmap.base.filter_warnings</code>","text":"<p>wfilter: {string} - \"ignore\": never print matching warnings; - \"always\": always print matching warnings</p> Source code in <code>brahmap/base/misc.py</code> <pre><code>def filter_warnings(wfilter):\n    \"\"\"\n    wfilter: {string}\n    - \"ignore\": never print matching warnings;\n    - \"always\": always print matching warnings\n\n    \"\"\"\n    warnings.simplefilter(wfilter)\n</code></pre>"},{"location":"api_reference/utilities/","title":"Utilities","text":""},{"location":"api_reference/utilities/#tools","title":"Tools","text":"<ul> <li><code>bash_colors</code></li> <li><code>modify_numpy_context</code></li> </ul>"},{"location":"api_reference/utilities/#visualization","title":"Visualization","text":"<ul> <li><code>plot_LinearOperator</code></li> </ul>"},{"location":"api_reference/utilities/bash_colors/","title":"<code>brahmap.utilities.bash_colors</code>","text":"<p>This class contains the necessary definitions to print to bash screen with colors. Sometimes it can be useful...</p> Source code in <code>brahmap/utilities/tools.py</code> <pre><code>class bash_colors:\n    \"\"\"\n    This class contains the necessary definitions to print to bash\n    screen with colors. Sometimes it can be useful...\n    \"\"\"\n\n    HEADER = \"\\033[95m\"\n    OKBLUE = \"\\033[94m\"\n    OKGREEN = \"\\033[92m\"\n    WARNING = \"\\033[93m\"\n    FAIL = \"\\033[91m\"\n    ENDC = \"\\033[0m\"\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n\n    def header(self, string):\n        return self.HEADER + str(string) + self.ENDC\n\n    def blue(self, string):\n        return self.OKBLUE + str(string) + self.ENDC\n\n    def green(self, string):\n        return self.OKGREEN + str(string) + self.ENDC\n\n    def warning(self, string):\n        return self.WARNING + str(string) + self.ENDC\n\n    def fail(self, string):\n        return self.FAIL + str(string) + self.ENDC\n\n    def bold(self, string):\n        return self.BOLD + str(string) + self.ENDC\n\n    def underline(self, string):\n        return self.UNDERLINE + str(string) + self.ENDC\n</code></pre>"},{"location":"api_reference/utilities/modify_numpy_context/","title":"<code>brahmap.utilities.modify_numpy_context</code>","text":"<p>               Bases: <code>object</code></p> <p>A context manager that replaces <code>np.linalg.norm</code> with <code>parallel_norm</code></p> Source code in <code>brahmap/utilities/tools.py</code> <pre><code>class modify_numpy_context(object):\n    \"\"\"A context manager that replaces `np.linalg.norm` with `parallel_norm`\"\"\"\n\n    def __init__(self):\n        self.parallel_norm = parallel_norm\n        self.original_norm = np.linalg.norm\n\n    def __enter__(self):\n        np.linalg.norm = self.parallel_norm\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        np.linalg.norm = self.original_norm\n</code></pre>"},{"location":"api_reference/utilities/plot_LinearOperator/","title":"<code>brahmap.utilities.plot_LinearOperator</code>","text":"<p>A utility function to visualize BrahMap linear operators. Make sure that <code>matplotlib</code> is installed if you want to use it.</p> <p>Warning</p> <p>This method first allocates a NumPy array of shape <code>self.shape</code> and data-type <code>self.dtype</code>, and then fills them with numbers. As such it can occupy an enormous amount of memory. Don't use it unless you understand the risk!</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>LinearOperator</code> <p>description</p> required Source code in <code>brahmap/utilities/visualizations.py</code> <pre><code>def plot_LinearOperator(\n    operator: LinearOperator,\n):\n    \"\"\"A utility function to visualize BrahMap linear operators. Make sure that `matplotlib` is installed if you want to use it.\n\n    !!! Warning\n\n        This method first allocates a NumPy array of shape `self.shape`\n        and data-type `self.dtype`, and then fills them with numbers. As\n        such it can occupy an enormous amount of memory. Don't use it\n        unless you understand the risk!\n\n    Parameters\n    ----------\n    operator : LinearOperator\n        _description_\n    \"\"\"\n    plt.figure()\n    plt.imshow(operator.to_array())\n\n    plt.tick_params(\n        axis=\"both\",\n        bottom=False,\n        left=False,\n        labelbottom=False,\n        labelleft=False,\n    )\n\n    ax = plt.gca()\n\n    row_size = getattr(operator, \"row_size\", [operator.nargout])\n    col_size = getattr(operator, \"col_size\", [operator.nargin])\n\n    tic = -0.5\n    ax.set_xticks(\n        [tic + np.sum(col_size[:idx]) for idx in range(len(col_size))],\n        minor=True,\n    )\n    ax.set_yticks(\n        [tic + np.sum(row_size[:idx]) for idx in range(len(row_size))],\n        minor=True,\n    )\n\n    ax.grid(which=\"minor\", color=\"w\", linestyle=\"-\", linewidth=1)\n\n    ax.tick_params(which=\"minor\", bottom=False, left=False)\n    plt.colorbar()\n</code></pre>"},{"location":"changelog/","title":"Release Notes","text":"<p>Under development!</p>"},{"location":"development/","title":"Development","text":"<p>Under development!</p>"},{"location":"overview/installation/","title":"Installation","text":"<p>The versions of the dependencies for <code>BrahMap</code> are quite flexible. If you intend to use <code>BrahMap</code> alongside other packages (like <code>litebird_sim</code>), we recommend installing <code>BrahMap</code> after you have installed those packages in the same environment.</p> <p><code>BrahMap</code> requires an MPI library to compile the C++ extensions. By default, it uses the <code>mpicxx</code> compiler wrapper for this task. However, you can override this default by setting the <code>MPICXX</code> environment variable to your preferred compiler. To install <code>BrahMap</code>, please follow these steps:</p> <pre><code># Clone the repository\ngit clone --recursive https://github.com/anand-avinash/BrahMap.git\n\n# Enter the directory\ncd BrahMap\n\n# Set the compiler you want to use (optional)\nexport MPICXX=mpiicpc\n\n# Install the package\npip install .\n\n# Alternatively, do an editable installation for development purpose\n# followed by `pre-commit` install\npip install -e .\npre-commit install\n</code></pre> <p>Note</p> <p><code>BrahMap</code> uses Setuptools to build the C++ extensions. By default, it generates the compilation command by gathering various environment variables. You can customize the compilation flags used during the installation by setting the <code>CXXFLAGS</code>, <code>CPPFLAGS</code>, and <code>LDFLAGS</code> environment variables.</p>"},{"location":"overview/license/","title":"MIT License","text":"<p>Copyright (c) 2023-present Avinash Anand and Giuseppe Puglisi</p> <p>All rights reserved.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"overview/name/","title":"What is in the name?","text":"<p>Under development!</p>"},{"location":"overview/roadmap/","title":"Roadmap","text":"<p>Under development!</p>"},{"location":"quick_start/","title":"BrahMap quick start guide","text":"<p>Complete example scripts and notebooks can be found here.</p> <p>By default, <code>BrahMap</code> performs all the operations over global MPI communicator (<code>MPI.COMM_WORLD</code>). To modify this behavior, one can specify a different MPI communicator through the function <code>brahmap.MPI_UTILS.update_communicator(comm=...)</code>. This function must be called before calling any other <code>BrahMap</code> functions.</p>"},{"location":"quick_start/#general-map-making","title":"General map-making","text":"<p>A generic map-making using <code>BrahMap</code> roughly involve four steps:</p> <ol> <li> <p>Pre-processing the pointing information (assuming that signal contains    uncorrelated noise)</p> <pre><code># Creating the inverse white noise covariance operator\ninv_cov = brahmap.InvNoiseCovLO_Diagonal(\n    size=nsamples,      # Size of the inverse noise covariance operator\n\n    input=[...],        # Noise covariance (variance for stationary white \n                        # noise) array\n\n    dtype=np.float64,   # Numerical precision of the operator\n)\n\n# Pre-processing the pointing information\nprocessed_samples = brahmap.ProcessTimeSamples(\n    npix=npix,                  # Number of pixels on which the map-making \n                                # has to be done\n\n    pointings=pointings,        # A 1-d of pointing indices\n\n    pol_angles=pol_angles,      # A 1-d array containing the polarization angles\n                                # of the detectors\n\n    noise_weights=inv_cov.diag, # A 1-d array of noise weights, or the diagonal\n                                # elements of the inverse noise covariance matrix\n\n    dtype_float=numpy.float64,  # Numerical precision to be used throughout the\n                                # map-making\n)\n</code></pre> </li> <li> <p>Creating linear operators</p> <pre><code># Pointing operator\npointing_LO = brahmap.PointingLO(processed_samples)\n\n# Block-diagonal preconditioner\nprecond_LO = brahmap.BlockDiagonalPreconditionerLO(processed_samples)\n</code></pre> </li> <li> <p>Performing the map-making (GLS in this example)</p> <pre><code>A = pointing_LO.T * inv_cov * pointing_LO\nb = pointing_LO.T * inv_cov * tod_array\n\n# Solving for x in the linear equation A.x=b using preconditioner\nmap_vector = scipy.sparse.linalg.cg(A, b, M=precond_LO)\n</code></pre> </li> <li> <p>Post-processing to produce the sky maps. Note that <code>map_vector</code> from    previous step contains maps in the form \\([I_1, Q_1, U_1, I_2, Q_2, U_2, \\dots]\\).    This has to be separated into I, Q, and U maps while taking care of the    unobserved (masked) pixels.</p> <pre><code># Separate I, Q, and U maps\noutput_maps = separate_map_vectors(map_vector, processed_samples)\n\n# output_maps[0] --&gt; I map\n# output_maps[1] --&gt; Q map\n# output_maps[2] --&gt; U map\n</code></pre> </li> </ol>"},{"location":"quick_start/#gls-map-making","title":"GLS map-making","text":"<p><code>BrahMap</code> provides a simple wrapper function for GLS map-making as well:</p> <pre><code># Creating the inverse white noise covariance operator\ninv_cov = brahmap.InvNoiseCovLO_Diagonal(\n    size=nsamples,      # Size of the inverse noise covariance operator\n\n    input=[...],        # Noise covariance (variance for stationary white \n                        # noise) array\n\n    dtype=np.float64,   # Numerical precision of the operator\n)\n\n# Performing the GLS map-making\ngls_result = brahmap.compute_GLS_maps(\n    npix=npix,                      # Number of pixels on which the map-making\n                                    # has to be done\n\n    pointings=pointings,            # A 1-d of pointing indices\n\n    time_ordered_data=tod_array,    # A 1-d array of time-ordered-data\n\n    pol_angles=pol_angles,          # A 1-d array containing the polarization angles\n                                    # of the detectors\n\n    inv_noise_cov_operator=inv_cov, # Inverse noise covariance operator\n\n    dtype_float=np.float64,         # Numerical precision to be used in map-making\n)\n</code></pre> <p><code>gls_result</code> obtained above is an instance of the class <code>GLSResult</code>. The output maps can be accessed from this object with <code>gls_result.GLS_maps</code>.</p>"},{"location":"quick_start/#gls-map-making-with-litebird_sim-data","title":"GLS map-making with <code>litebird_sim</code> data","text":"<p><code>BrahMap</code> is also integrated with the LiteBIRD simulation framework <code>litebird_sim</code>. It provides a wrapper function for GLS map-making that uses a list of <code>Observation</code> instances and a suitable inverse noise covariance operator to produce the sky maps.</p> <p>The MPI communicator used in map-making must be the one that contains exclusively all the data needed for map-making. In case of <code>litebird_sim</code>, the communicator <code>lbs.MPI_COMM_GRID.COMM_OBS_GRID</code> is a subset of <code>lbs.MPI_COMM_WORLD</code>, and it excludes the MPI processes that do not contain any detectors (and TODs). Therefore, it is a suitable communicator to be used in map-making. Therefore, communicator used by <code>BrahMap</code> must be updated as following before using any other <code>BrahMap</code> function with <code>litebird_sim</code> data: <code>brahmap.MPI_UTILS.update_communicator(comm=lbs.MPI_COMM_GRID.COMM_OBS_GRID)</code></p> <pre><code># Creating the inverse white noise covariance operator\ninv_cov = brahmap.InvNoiseCovLO_Diagonal(\n    size=nsamples,      # Size of the inverse noise covariance operator\n\n    input=[...],        # Noise covariance (variance for stationary white \n                        # noise) array\n\n    dtype=np.float64,   # Numerical precision of the operator\n)\n\n# Performing the GLS map-making\ngls_result = brahmap.LBSim_compute_GLS_maps(\n    nside=nside,                    # Nside parameter for the output healpix map\n    observations=sim.observations,  # List of observations from litebird_sim\n    components=\"tod\",                # TOD component to be used in map-making\n    inv_noise_cov_operator=inv_cov, # Inverse noise covariance operator\n    dtype_float=np.float64,         # Numerical precision to be used in map-making\n)\n</code></pre> <p><code>gls_result</code> obtained above is an instance of the class <code>LBSimGLSResult</code>. The output maps can be accessed from this object with <code>gls_result.GLS_maps</code>.</p>"},{"location":"user_guide/","title":"User Guide","text":"<p>Under development!</p>"}]}